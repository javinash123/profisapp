{"file_contents":{"client/screens/WeatherDetailsScreen.tsx":{"content":"import React, { useEffect } from \"react\";\nimport { View, StyleSheet, Pressable, ScrollView, ActivityIndicator } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport Animated, { FadeInUp } from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Card } from \"@/components/Card\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\n\nexport default function WeatherDetailsScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const navigation = useNavigation();\n  const { theme } = useTheme();\n  const { weather, refreshWeather } = useApp();\n\n  const [isRefreshing, setIsRefreshing] = React.useState(false);\n\n  useEffect(() => {\n    if (!weather) {\n      handleRefresh();\n    }\n  }, []);\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      headerRight: () => (\n        <Pressable\n          onPress={handleRefresh}\n          hitSlop={8}\n          style={({ pressed }) => ({ opacity: pressed ? 0.6 : 1 })}\n          disabled={isRefreshing}\n        >\n          {isRefreshing ? (\n            <ActivityIndicator size=\"small\" color={theme.text} />\n          ) : (\n            <Feather name=\"refresh-cw\" size={22} color={theme.text} />\n          )}\n        </Pressable>\n      ),\n    });\n  }, [navigation, theme, isRefreshing]);\n\n  const handleRefresh = async () => {\n    setIsRefreshing(true);\n    await refreshWeather();\n    setIsRefreshing(false);\n  };\n\n  const formatLastUpdated = (timestamp: number): string => {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" });\n  };\n\n  if (!weather) {\n    return (\n      <ThemedView style={styles.container}>\n        <View style={styles.loading}>\n          <ActivityIndicator size=\"large\" color={Colors.dark.primary} />\n          <ThemedText type=\"body\" style={{ marginTop: Spacing.lg, color: theme.textSecondary }}>\n            Loading weather data...\n          </ThemedText>\n        </View>\n      </ThemedView>\n    );\n  }\n\n  const weatherMetrics = [\n    {\n      icon: \"thermometer\",\n      label: \"Temperature\",\n      value: `${weather.temperature}°C`,\n      color: Colors.dark.primary,\n    },\n    {\n      icon: \"droplet\",\n      label: \"Humidity\",\n      value: `${weather.humidity}%`,\n      color: Colors.dark.secondary,\n    },\n    {\n      icon: \"wind\",\n      label: \"Wind Speed\",\n      value: `${weather.windSpeed} mph`,\n      color: Colors.dark.warning,\n    },\n    {\n      icon: \"bar-chart-2\",\n      label: \"Pressure\",\n      value: `${weather.pressure} mb`,\n      color: Colors.dark.success,\n    },\n  ];\n\n  return (\n    <ThemedView style={styles.container}>\n      <ScrollView\n        contentContainerStyle={[\n          styles.content,\n          {\n            paddingTop: headerHeight + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl,\n          },\n        ]}\n        showsVerticalScrollIndicator={false}\n      >\n        {weather.isOffline ? (\n          <View style={[styles.offlineBanner, { backgroundColor: Colors.dark.warning + \"30\" }]}>\n            <Feather name=\"wifi-off\" size={16} color={Colors.dark.warning} />\n            <ThemedText type=\"small\" style={{ color: Colors.dark.warning, marginLeft: Spacing.sm }}>\n              Offline - Showing cached data\n            </ThemedText>\n          </View>\n        ) : null}\n\n        <View style={styles.lastUpdated}>\n          <Feather name=\"clock\" size={14} color={theme.textSecondary} />\n          <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: Spacing.xs }}>\n            Last updated: {formatLastUpdated(weather.lastUpdated)}\n          </ThemedText>\n        </View>\n\n        <Animated.View entering={FadeInUp.delay(100)}>\n          <Card elevation={1} style={styles.mainCard}>\n            <View style={styles.mainWeather}>\n              <Feather name=\"cloud\" size={48} color={Colors.dark.secondary} />\n              <ThemedText type=\"h1\" style={{ marginTop: Spacing.md }}>\n                {weather.temperature}°C\n              </ThemedText>\n              <ThemedText type=\"body\" style={{ color: theme.textSecondary, marginTop: Spacing.xs }}>\n                {weather.description}\n              </ThemedText>\n            </View>\n          </Card>\n        </Animated.View>\n\n        <View style={styles.metricsGrid}>\n          {weatherMetrics.map((metric, index) => (\n            <Animated.View\n              key={metric.label}\n              entering={FadeInUp.delay(200 + index * 50)}\n              style={styles.metricWrapper}\n            >\n              <Card elevation={1} style={styles.metricCard}>\n                <View style={[styles.metricIcon, { backgroundColor: metric.color + \"20\" }]}>\n                  <Feather name={metric.icon as any} size={20} color={metric.color} />\n                </View>\n                <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginTop: Spacing.sm }}>\n                  {metric.label}\n                </ThemedText>\n                <ThemedText type=\"h4\" style={{ marginTop: Spacing.xs }}>\n                  {metric.value}\n                </ThemedText>\n              </Card>\n            </Animated.View>\n          ))}\n        </View>\n\n        <Animated.View entering={FadeInUp.delay(400)}>\n          <Card elevation={1} style={styles.pressureCard}>\n            <View style={styles.pressureHeader}>\n              <ThemedText type=\"h4\">Pressure Trend</ThemedText>\n              <View style={styles.trendBadge}>\n                <Feather\n                  name={\n                    weather.pressureTrend === \"rising\"\n                      ? \"trending-up\"\n                      : weather.pressureTrend === \"falling\"\n                      ? \"trending-down\"\n                      : \"minus\"\n                  }\n                  size={16}\n                  color={\n                    weather.pressureTrend === \"rising\"\n                      ? Colors.dark.success\n                      : weather.pressureTrend === \"falling\"\n                      ? Colors.dark.error\n                      : theme.textSecondary\n                  }\n                />\n                <ThemedText\n                  type=\"small\"\n                  style={{\n                    marginLeft: Spacing.xs,\n                    color:\n                      weather.pressureTrend === \"rising\"\n                        ? Colors.dark.success\n                        : weather.pressureTrend === \"falling\"\n                        ? Colors.dark.error\n                        : theme.textSecondary,\n                    textTransform: \"capitalize\",\n                  }}\n                >\n                  {weather.pressureTrend}\n                </ThemedText>\n              </View>\n            </View>\n\n            <View style={styles.pressureGraph}>\n              <View style={[styles.graphBar, { backgroundColor: theme.backgroundTertiary }]}>\n                <View\n                  style={[\n                    styles.graphFill,\n                    {\n                      height: `${Math.min(((weather.pressure - 990) / 50) * 100, 100)}%`,\n                      backgroundColor: Colors.dark.secondary,\n                    },\n                  ]}\n                />\n              </View>\n              <View style={styles.graphLabels}>\n                <ThemedText type=\"caption\" style={{ color: theme.textSecondary }}>\n                  1040 mb\n                </ThemedText>\n                <ThemedText type=\"h3\">{weather.pressure} mb</ThemedText>\n                <ThemedText type=\"caption\" style={{ color: theme.textSecondary }}>\n                  990 mb\n                </ThemedText>\n              </View>\n            </View>\n\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginTop: Spacing.lg }}>\n              {weather.pressureTrend === \"rising\"\n                ? \"Rising pressure often indicates improving weather conditions.\"\n                : weather.pressureTrend === \"falling\"\n                ? \"Falling pressure may indicate approaching weather changes.\"\n                : \"Stable pressure suggests consistent weather conditions.\"}\n            </ThemedText>\n          </Card>\n        </Animated.View>\n      </ScrollView>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  loading: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  offlineBanner: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.md,\n  },\n  lastUpdated: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  mainCard: {\n    marginBottom: Spacing.lg,\n    paddingVertical: Spacing[\"2xl\"],\n  },\n  mainWeather: {\n    alignItems: \"center\",\n  },\n  metricsGrid: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  metricWrapper: {\n    width: \"48%\",\n  },\n  metricCard: {\n    padding: Spacing.lg,\n  },\n  metricIcon: {\n    width: 40,\n    height: 40,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  pressureCard: {\n    padding: Spacing.lg,\n  },\n  pressureHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  trendBadge: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  pressureGraph: {\n    flexDirection: \"row\",\n    height: 120,\n    gap: Spacing.lg,\n  },\n  graphBar: {\n    width: 24,\n    borderRadius: BorderRadius.xs,\n    overflow: \"hidden\",\n    justifyContent: \"flex-end\",\n  },\n  graphFill: {\n    width: \"100%\",\n    borderRadius: BorderRadius.xs,\n  },\n  graphLabels: {\n    flex: 1,\n    justifyContent: \"space-between\",\n    alignItems: \"flex-start\",\n  },\n});\n","path":null,"size_bytes":10254,"size_tokens":null},"client/lib/utils.ts":{"content":"import { WeightUnit } from \"./types\";\n\nexport function formatWeight(grams: number, unit: WeightUnit): string {\n  if (unit === \"kg/g\") {\n    if (grams >= 1000) {\n      const kg = Math.floor(grams / 1000);\n      const g = Math.round(grams % 1000);\n      return g > 0 ? `${kg}.${String(g).padStart(3, \"0\").slice(0, 1)}kg` : `${kg}kg`;\n    }\n    return `${Math.round(grams)}g`;\n  } else {\n    const totalOunces = grams / 28.3495;\n    const pounds = Math.floor(totalOunces / 16);\n    const ounces = Math.round(totalOunces % 16);\n    return `${pounds}lb ${ounces}oz`;\n  }\n}\n\nexport function parseWeight(value: string, unit: WeightUnit): number {\n  const num = parseFloat(value) || 0;\n  if (unit === \"kg/g\") {\n    return num;\n  } else {\n    return num * 28.3495;\n  }\n}\n\nexport function formatTime(seconds: number): string {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = seconds % 60;\n  \n  if (hrs > 0) {\n    return `${hrs}:${String(mins).padStart(2, \"0\")}:${String(secs).padStart(2, \"0\")}`;\n  }\n  return `${String(mins).padStart(2, \"0\")}:${String(secs).padStart(2, \"0\")}`;\n}\n\nexport function formatDuration(minutes: number): string {\n  const hrs = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  if (hrs > 0) {\n    return mins > 0 ? `${hrs}h ${mins}m` : `${hrs}h`;\n  }\n  return `${mins}m`;\n}\n\nexport function generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\nexport function getProgressColor(percentage: number, colors: { success: string; warning: string; error: string }): string {\n  if (percentage < 80) return colors.success;\n  if (percentage <= 100) return colors.warning;\n  return colors.error;\n}\n","path":null,"size_bytes":1710,"size_tokens":null},"client/components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const backgroundColor =\n    isDark && darkColor\n      ? darkColor\n      : !isDark && lightColor\n        ? lightColor\n        : theme.backgroundRoot;\n\n  return <View style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n","path":null,"size_bytes":563,"size_tokens":null},"client/constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nexport const Colors = {\n  light: {\n    text: \"#FFFFFF\",\n    textSecondary: \"#A8B3BD\",\n    textMuted: \"#6F7C87\",\n    buttonText: \"#FFFFFF\",\n    buttonTextDark: \"#05120C\",\n    tabIconDefault: \"#6F7C87\",\n    tabIconSelected: \"#3CFFB0\",\n    link: \"#2F8CFF\",\n    backgroundRoot: \"#05080B\",\n    backgroundDefault: \"#0B1218\",\n    backgroundSecondary: \"#111A22\",\n    backgroundTertiary: \"#1C2A35\",\n    primary: \"#3CFFB0\",\n    primarySoft: \"#2EDC9C\",\n    secondary: \"#2F8CFF\",\n    secondaryMuted: \"#1E5FAF\",\n    success: \"#41F5A3\",\n    warning: \"#F6C343\",\n    warningAmber: \"#E9B949\",\n    warningMuted: \"#D8B55A\",\n    error: \"#FF4D4D\",\n    errorDark: \"#8B1E1E\",\n    border: \"#1C2A35\",\n    disabled: \"#2A333B\",\n    disabledText: \"#6F7C87\",\n  },\n  dark: {\n    text: \"#FFFFFF\",\n    textSecondary: \"#A8B3BD\",\n    textMuted: \"#6F7C87\",\n    buttonText: \"#FFFFFF\",\n    buttonTextDark: \"#05120C\",\n    tabIconDefault: \"#6F7C87\",\n    tabIconSelected: \"#3CFFB0\",\n    link: \"#2F8CFF\",\n    backgroundRoot: \"#05080B\",\n    backgroundDefault: \"#0B1218\",\n    backgroundSecondary: \"#111A22\",\n    backgroundTertiary: \"#1C2A35\",\n    primary: \"#3CFFB0\",\n    primarySoft: \"#2EDC9C\",\n    secondary: \"#2F8CFF\",\n    secondaryMuted: \"#1E5FAF\",\n    success: \"#41F5A3\",\n    warning: \"#F6C343\",\n    warningAmber: \"#E9B949\",\n    warningMuted: \"#D8B55A\",\n    error: \"#FF4D4D\",\n    errorDark: \"#8B1E1E\",\n    border: \"#1C2A35\",\n    disabled: \"#2A333B\",\n    disabledText: \"#6F7C87\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 32,\n  \"4xl\": 40,\n  \"5xl\": 48,\n  inputHeight: 48,\n  buttonHeight: 56,\n};\n\nexport const BorderRadius = {\n  xs: 8,\n  sm: 12,\n  md: 18,\n  lg: 24,\n  xl: 30,\n  \"2xl\": 40,\n  \"3xl\": 50,\n  full: 9999,\n};\n\nexport const Typography = {\n  timer: {\n    fontSize: 48,\n    fontWeight: \"700\" as const,\n    fontVariant: [\"tabular-nums\"] as (\"tabular-nums\")[],\n  },\n  h1: {\n    fontSize: 32,\n    fontWeight: \"700\" as const,\n  },\n  h2: {\n    fontSize: 28,\n    fontWeight: \"700\" as const,\n  },\n  h3: {\n    fontSize: 20,\n    fontWeight: \"600\" as const,\n  },\n  h4: {\n    fontSize: 18,\n    fontWeight: \"600\" as const,\n  },\n  bodyLarge: {\n    fontSize: 24,\n    fontWeight: \"500\" as const,\n  },\n  body: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  caption: {\n    fontSize: 12,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    sans: \"system-ui\",\n    serif: \"ui-serif\",\n    rounded: \"ui-rounded\",\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded:\n      \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\",\n  },\n});\n\nexport const Shadows = {\n  small: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 2,\n    elevation: 2,\n  },\n  medium: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.15,\n    shadowRadius: 4,\n    elevation: 4,\n  },\n  large: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 8 },\n    shadowOpacity: 0.2,\n    shadowRadius: 8,\n    elevation: 8,\n  },\n  glowGreen: {\n    shadowColor: \"#3CFFB0\",\n    shadowOffset: { width: 0, height: 0 },\n    shadowOpacity: 0.45,\n    shadowRadius: 12,\n    elevation: 8,\n  },\n  glowRed: {\n    shadowColor: \"#FF4D4D\",\n    shadowOffset: { width: 0, height: 0 },\n    shadowOpacity: 0.35,\n    shadowRadius: 10,\n    elevation: 6,\n  },\n  glowBlue: {\n    shadowColor: \"#2F8CFF\",\n    shadowOffset: { width: 0, height: 0 },\n    shadowOpacity: 0.35,\n    shadowRadius: 10,\n    elevation: 6,\n  },\n};\n","path":null,"size_bytes":4090,"size_tokens":null},"shared/schema.ts":{"content":"import { sql } from \"drizzle-orm\";\nimport { pgTable, text, varchar } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  username: text(\"username\").notNull().unique(),\n  password: text(\"password\").notNull(),\n});\n\nexport const insertUserSchema = createInsertSchema(users).pick({\n  username: true,\n  password: true,\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\n","path":null,"size_bytes":594,"size_tokens":null},"server/index.ts":{"content":"import express from \"express\";\nimport type { Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst app = express();\nconst log = console.log;\n\ndeclare module \"http\" {\n  interface IncomingMessage {\n    rawBody: unknown;\n  }\n}\n\nfunction setupCors(app: express.Application) {\n  app.use((req, res, next) => {\n    const origins = new Set<string>();\n\n    if (process.env.REPLIT_DEV_DOMAIN) {\n      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);\n    }\n\n    if (process.env.REPLIT_DOMAINS) {\n      process.env.REPLIT_DOMAINS.split(\",\").forEach((d) => {\n        origins.add(`https://${d.trim()}`);\n      });\n    }\n\n    const origin = req.header(\"origin\");\n\n    if (origin && origins.has(origin)) {\n      res.header(\"Access-Control-Allow-Origin\", origin);\n      res.header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, POST, PUT, DELETE, OPTIONS\",\n      );\n      res.header(\"Access-Control-Allow-Headers\", \"Content-Type\");\n      res.header(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n\n    if (req.method === \"OPTIONS\") {\n      return res.sendStatus(200);\n    }\n\n    next();\n  });\n}\n\nfunction setupBodyParsing(app: express.Application) {\n  app.use(\n    express.json({\n      verify: (req, _res, buf) => {\n        req.rawBody = buf;\n      },\n    }),\n  );\n\n  app.use(express.urlencoded({ extended: false }));\n}\n\nfunction setupRequestLogging(app: express.Application) {\n  app.use((req, res, next) => {\n    const start = Date.now();\n    const path = req.path;\n    let capturedJsonResponse: Record<string, unknown> | undefined = undefined;\n\n    const originalResJson = res.json;\n    res.json = function (bodyJson, ...args) {\n      capturedJsonResponse = bodyJson;\n      return originalResJson.apply(res, [bodyJson, ...args]);\n    };\n\n    res.on(\"finish\", () => {\n      if (!path.startsWith(\"/api\")) return;\n\n      const duration = Date.now() - start;\n\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"…\";\n      }\n\n      log(logLine);\n    });\n\n    next();\n  });\n}\n\nfunction getAppName(): string {\n  try {\n    const appJsonPath = path.resolve(process.cwd(), \"app.json\");\n    const appJsonContent = fs.readFileSync(appJsonPath, \"utf-8\");\n    const appJson = JSON.parse(appJsonContent);\n    return appJson.expo?.name || \"App Landing Page\";\n  } catch {\n    return \"App Landing Page\";\n  }\n}\n\nfunction serveExpoManifest(platform: string, res: Response) {\n  const manifestPath = path.resolve(\n    process.cwd(),\n    \"static-build\",\n    platform,\n    \"manifest.json\",\n  );\n\n  if (!fs.existsSync(manifestPath)) {\n    return res\n      .status(404)\n      .json({ error: `Manifest not found for platform: ${platform}` });\n  }\n\n  res.setHeader(\"expo-protocol-version\", \"1\");\n  res.setHeader(\"expo-sfv-version\", \"0\");\n  res.setHeader(\"content-type\", \"application/json\");\n\n  const manifest = fs.readFileSync(manifestPath, \"utf-8\");\n  res.send(manifest);\n}\n\nfunction serveLandingPage({\n  req,\n  res,\n  landingPageTemplate,\n  appName,\n}: {\n  req: Request;\n  res: Response;\n  landingPageTemplate: string;\n  appName: string;\n}) {\n  const forwardedProto = req.header(\"x-forwarded-proto\");\n  const protocol = forwardedProto || req.protocol || \"https\";\n  const forwardedHost = req.header(\"x-forwarded-host\");\n  const host = forwardedHost || req.get(\"host\");\n  const baseUrl = `${protocol}://${host}`;\n  const expsUrl = `${host}`;\n\n  log(`baseUrl`, baseUrl);\n  log(`expsUrl`, expsUrl);\n\n  const html = landingPageTemplate\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl)\n    .replace(/APP_NAME_PLACEHOLDER/g, appName);\n\n  res.setHeader(\"Content-Type\", \"text/html; charset=utf-8\");\n  res.status(200).send(html);\n}\n\nfunction configureExpoAndLanding(app: express.Application) {\n  const templatePath = path.resolve(\n    process.cwd(),\n    \"server\",\n    \"templates\",\n    \"landing-page.html\",\n  );\n  const landingPageTemplate = fs.readFileSync(templatePath, \"utf-8\");\n  const appName = getAppName();\n\n  log(\"Serving static Expo files with dynamic manifest routing\");\n\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    if (req.path.startsWith(\"/api\")) {\n      return next();\n    }\n\n    if (req.path !== \"/\" && req.path !== \"/manifest\") {\n      return next();\n    }\n\n    const platform = req.header(\"expo-platform\");\n    if (platform && (platform === \"ios\" || platform === \"android\")) {\n      return serveExpoManifest(platform, res);\n    }\n\n    if (req.path === \"/\") {\n      return serveLandingPage({\n        req,\n        res,\n        landingPageTemplate,\n        appName,\n      });\n    }\n\n    next();\n  });\n\n  app.use(\"/assets\", express.static(path.resolve(process.cwd(), \"assets\")));\n  app.use(express.static(path.resolve(process.cwd(), \"static-build\")));\n\n  log(\"Expo routing: Checking expo-platform header on / and /manifest\");\n}\n\nfunction setupErrorHandler(app: express.Application) {\n  app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {\n    const error = err as {\n      status?: number;\n      statusCode?: number;\n      message?: string;\n    };\n\n    const status = error.status || error.statusCode || 500;\n    const message = error.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n\n    throw err;\n  });\n}\n\n(async () => {\n  setupCors(app);\n  setupBodyParsing(app);\n  setupRequestLogging(app);\n\n  configureExpoAndLanding(app);\n\n  const server = await registerRoutes(app);\n\n  setupErrorHandler(app);\n\n  const port = parseInt(process.env.PORT || \"5000\", 10);\n  server.listen(\n    {\n      port,\n      host: \"0.0.0.0\",\n      reusePort: true,\n    },\n    () => {\n      log(`express server serving on port ${port}`);\n    },\n  );\n})();\n","path":null,"size_bytes":5949,"size_tokens":null},"client/screens/EndMatchSummaryScreen.tsx":{"content":"import React, { useEffect, useState, useRef } from \"react\";\nimport { View, StyleSheet, Pressable, ScrollView, Share, Platform } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport Animated, { FadeInUp } from \"react-native-reanimated\";\nimport { captureRef } from \"react-native-view-shot\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Card } from \"@/components/Card\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { formatWeight, formatDuration } from \"@/lib/utils\";\nimport { MatchState } from \"@/lib/types\";\nimport { getMatchHistory } from \"@/lib/storage\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nexport default function EndMatchSummaryScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const navigation = useNavigation<NavigationProp>();\n  const { theme } = useTheme();\n  const { settings, lastCompletedMatch } = useApp();\n  const summaryRef = useRef<View>(null);\n\n  const [match, setMatch] = useState<MatchState | null>(null);\n\n  useEffect(() => {\n    if (lastCompletedMatch) {\n      setMatch(lastCompletedMatch);\n    } else {\n      loadLastMatch();\n    }\n  }, [lastCompletedMatch]);\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      headerRight: () => (\n        <Pressable\n          onPress={handleShare}\n          hitSlop={8}\n          style={({ pressed }) => ({ opacity: pressed ? 0.6 : 1 })}\n        >\n          <Feather name=\"share\" size={22} color={theme.text} />\n        </Pressable>\n      ),\n    });\n  }, [navigation, theme, match]);\n\n  const loadLastMatch = async () => {\n    const history = await getMatchHistory();\n    if (history.length > 0) {\n      setMatch(history[0]);\n    }\n  };\n\n  const handleShare = async () => {\n    if (!match || !summaryRef.current) return;\n    \n    try {\n      const uri = await captureRef(summaryRef, {\n        format: \"png\",\n        quality: 1,\n        result: \"tmpfile\",\n      });\n      \n      const totalWeight = match.nets.reduce((sum, net) => sum + net.weight, 0);\n      const summaryText = `PegPro Match Summary\\n\\n` +\n        `Match: ${match.config.name}\\n` +\n        `Peg: ${match.config.pegNumber}\\n` +\n        `Duration: ${formatDuration(match.config.durationMinutes)}\\n` +\n        `Total Weight: ${formatWeight(totalWeight, match.config.unit)}\\n\\n` +\n        match.nets.map((net, i) => `Net ${i + 1}: ${formatWeight(net.weight, match.config.unit)}`).join(\"\\n\");\n      \n      if (Platform.OS === \"web\") {\n        await Share.share({ message: summaryText });\n      } else {\n        await Share.share({\n          url: uri,\n          message: summaryText,\n          title: \"PegPro Match Summary\",\n        });\n      }\n    } catch (error) {\n      console.error(\"Share error:\", error);\n      const totalWeight = match.nets.reduce((sum, net) => sum + net.weight, 0);\n      const summaryText = `PegPro Match Summary\\n\\n` +\n        `Match: ${match.config.name}\\n` +\n        `Peg: ${match.config.pegNumber}\\n` +\n        `Duration: ${formatDuration(match.config.durationMinutes)}\\n` +\n        `Total Weight: ${formatWeight(totalWeight, match.config.unit)}\\n\\n` +\n        match.nets.map((net, i) => `Net ${i + 1}: ${formatWeight(net.weight, match.config.unit)}`).join(\"\\n\");\n      await Share.share({ message: summaryText });\n    }\n  };\n\n  const handleNewMatch = () => {\n    navigation.replace(\"MatchSetup\");\n  };\n\n  if (!match) {\n    return (\n      <ThemedView style={styles.container}>\n        <View style={styles.loading}>\n          <ThemedText>Loading...</ThemedText>\n        </View>\n      </ThemedView>\n    );\n  }\n\n  const totalWeight = match.nets.reduce((sum, net) => sum + net.weight, 0);\n\n  return (\n    <ThemedView style={styles.container}>\n      <ScrollView\n        contentContainerStyle={[\n          styles.content,\n          {\n            paddingTop: headerHeight + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl + 80,\n          },\n        ]}\n        showsVerticalScrollIndicator={false}\n      >\n        <View ref={summaryRef} collapsable={false} style={[styles.summaryContainer, { backgroundColor: Colors.dark.backgroundRoot }]}>\n          <View style={styles.summaryHeader}>\n            <ThemedText type=\"h3\" style={styles.summaryTitle}>PegPro Match Summary</ThemedText>\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary }}>{match.config.name}</ThemedText>\n          </View>\n\n          <Card elevation={1} style={styles.totalCard}>\n            <View style={styles.totalHeader}>\n              <Feather name=\"award\" size={32} color={Colors.dark.primary} />\n              <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginTop: Spacing.sm }}>\n                Total Weight\n              </ThemedText>\n            </View>\n            <ThemedText style={styles.totalWeight}>\n              {formatWeight(totalWeight, match.config.unit)}\n            </ThemedText>\n          </Card>\n\n          <View style={styles.matchInfo}>\n            <View style={styles.infoRow}>\n              <View style={styles.infoItem}>\n                <Feather name=\"flag\" size={18} color={theme.textSecondary} />\n                <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: Spacing.xs }}>\n                  Peg {match.config.pegNumber}\n                </ThemedText>\n              </View>\n              <View style={styles.infoItem}>\n                <Feather name=\"clock\" size={18} color={theme.textSecondary} />\n                <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: Spacing.xs }}>\n                  {formatDuration(match.config.durationMinutes)}\n                </ThemedText>\n              </View>\n              <View style={styles.infoItem}>\n                <Feather name=\"grid\" size={18} color={theme.textSecondary} />\n                <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: Spacing.xs }}>\n                  {match.config.numberOfNets} Nets\n                </ThemedText>\n              </View>\n            </View>\n          </View>\n\n          <ThemedText type=\"h4\" style={styles.sectionTitle}>Per-Net Breakdown</ThemedText>\n\n          {match.nets.map((net, index) => {\n            const percentage = net.capacity ? (net.weight / net.capacity) * 100 : 0;\n            const isOverCapacity = percentage > 100;\n\n            return (\n              <Card key={index} elevation={1} style={styles.netCard}>\n                <View style={styles.netCardContent}>\n                  <View style={styles.netInfo}>\n                    <ThemedText type=\"body\" style={{ fontWeight: \"600\" }}>Net {index + 1}</ThemedText>\n                    {isOverCapacity ? (\n                      <View style={[styles.overCapacityBadge, { backgroundColor: Colors.dark.error + \"30\" }]}>\n                        <Feather name=\"alert-circle\" size={12} color={Colors.dark.error} />\n                        <ThemedText type=\"caption\" style={{ color: Colors.dark.error, marginLeft: 4 }}>\n                          Over Capacity\n                        </ThemedText>\n                      </View>\n                    ) : null}\n                  </View>\n                  <ThemedText type=\"h4\">{formatWeight(net.weight, match.config.unit)}</ThemedText>\n                </View>\n                {net.capacity ? (\n                  <View style={styles.capacityInfo}>\n                    <View style={[styles.progressBar, { backgroundColor: theme.backgroundTertiary }]}>\n                      <View\n                        style={[\n                          styles.progressFill,\n                          {\n                            width: `${Math.min(percentage, 100)}%`,\n                            backgroundColor: isOverCapacity ? Colors.dark.error : Colors.dark.success,\n                          },\n                        ]}\n                      />\n                    </View>\n                    <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginTop: 4 }}>\n                      {Math.round(percentage)}% of capacity\n                    </ThemedText>\n                  </View>\n                ) : null}\n              </Card>\n            );\n          })}\n        </View>\n      </ScrollView>\n\n      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing.lg }]}>\n        <Pressable\n          onPress={handleNewMatch}\n          style={({ pressed }) => [\n            styles.newMatchButton,\n            { backgroundColor: Colors.dark.primary, opacity: pressed ? 0.8 : 1 },\n          ]}\n        >\n          <Feather name=\"plus\" size={22} color=\"#FFFFFF\" />\n          <ThemedText type=\"body\" style={styles.newMatchButtonText}>\n            New Match\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  loading: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  summaryContainer: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n  },\n  summaryHeader: {\n    alignItems: \"center\",\n    marginBottom: Spacing.lg,\n  },\n  summaryTitle: {\n    marginBottom: Spacing.xs,\n  },\n  totalCard: {\n    alignItems: \"center\",\n    paddingVertical: Spacing[\"2xl\"],\n  },\n  totalHeader: {\n    alignItems: \"center\",\n  },\n  totalWeight: {\n    ...Typography.timer,\n    marginTop: Spacing.sm,\n  },\n  matchInfo: {\n    marginTop: Spacing.xl,\n    marginBottom: Spacing[\"2xl\"],\n  },\n  infoRow: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing.xl,\n  },\n  infoItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  sectionTitle: {\n    marginBottom: Spacing.md,\n  },\n  netCard: {\n    marginBottom: Spacing.sm,\n    padding: Spacing.lg,\n  },\n  netCardContent: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n  },\n  netInfo: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  overCapacityBadge: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: 2,\n    borderRadius: BorderRadius.xs,\n  },\n  capacityInfo: {\n    marginTop: Spacing.sm,\n  },\n  progressBar: {\n    height: 4,\n    borderRadius: 2,\n    overflow: \"hidden\",\n  },\n  progressFill: {\n    height: \"100%\",\n  },\n  footer: {\n    position: \"absolute\",\n    bottom: 0,\n    left: 0,\n    right: 0,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  newMatchButton: {\n    height: 56,\n    borderRadius: BorderRadius.sm,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.sm,\n  },\n  newMatchButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":11270,"size_tokens":null},"babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./client\",\n            \"@shared\": \"./shared\",\n            \"@assets\": \"./attached_assets\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","path":null,"size_bytes":480,"size_tokens":null},"design_guidelines.md":{"content":"# PegPro Fishing Match Tracker - Design Guidelines\n\n## Authentication\n**No authentication required.** This is a single-user, local-first utility app. All match data persists locally using AsyncStorage.\n\n**Profile/Settings Screen Required:**\n- User avatar selection (generate 3 fishing-themed preset avatars: angler silhouette, fish icon, hook icon)\n- Display name field (defaults to \"Angler\")\n- App preferences: units (lb/oz vs kg/g), theme, haptics, sound, weather API key\n\n## Navigation Architecture\n\n**Stack-Only Navigation** - Linear flow optimized for active match usage:\n1. **Onboarding Stack** (first-time users only): Welcome → Permissions\n2. **Main Stack**: Match Setup → Live Match → End Match Summary\n3. **Modal Overlays**: Manual Weight Edit, Alarm Management, Add/Edit Alarm, Weather Details, Settings, Lock Mode\n\n**Flow:**\n- App opens to Match Setup screen (or Live Match if match in progress)\n- Live Match is the persistent core screen during active matches\n- Modals slide up from bottom for quick actions\n- Lock Mode is a full-screen overlay preventing accidental touches\n\n## Screen Specifications\n\n### 1. Welcome/Onboarding Screen\n- **Purpose:** First-time intro and permissions request\n- **Layout:**\n  - Transparent header, no navigation buttons\n  - Scrollable content area with 3 feature cards (timer tracking, multi-net monitoring, weather integration)\n  - Bottom fixed area with \"Get Started\" CTA button\n  - Safe area insets: top: insets.top + Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **Components:** Feature cards with Feather icons, permission request alerts (native modals)\n\n### 2. Match Setup Screen\n- **Purpose:** Configure new match parameters\n- **Layout:**\n  - Default header with title \"New Match\", right button: \"Settings\" (gear icon)\n  - Scrollable form with sections\n  - Bottom fixed \"Start Match\" button (coral-red, full-width with shadow)\n  - Safe area insets: top: Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **Form Fields:**\n  - Match name (text input)\n  - Duration (hour/minute picker)\n  - Peg number (numeric input)\n  - Number of nets (1-6 horizontal selector)\n  - Per-net capacity (optional numeric input with unit suffix)\n  - Units toggle (lb/oz or kg/g segmented control)\n  - \"Keep screen on\" switch\n\n### 3. Live Match Screen (Core)\n- **Purpose:** Real-time match monitoring and weight tracking\n- **Layout:**\n  - Custom transparent header with:\n    - Left: Lock icon button\n    - Center: Large countdown timer (MM:SS)\n    - Right: Weather icon button, Menu icon (3-dot)\n  - Top status bar: Temperature, pressure trend (arrow icon), wind speed\n  - Main content: 2×3 grid of net tiles (non-scrollable, fills screen)\n  - Bottom fixed panel: Total weight display, alarm indicator, quick add alarm button\n  - Safe area insets: top: headerHeight + Spacing.sm, bottom: insets.bottom + Spacing.md\n- **Net Tile Components:**\n  - Large weight display (center)\n  - Subtract button (left, circular, teal)\n  - Add button (right, circular, coral-red)\n  - Progress bar below weight (color-coded: green < 80%, amber 80-100%, red > 100%)\n  - Manual edit icon (small, top-right corner)\n  - Tile background changes based on status (dark navy default, subtle glow when active)\n\n### 4. Manual Weight Edit Modal\n- **Purpose:** Quick numeric weight entry\n- **Layout:**\n  - Modal slides from bottom, 60% screen height\n  - Header: \"Edit Net X Weight\", Close button\n  - Large numeric keypad (3×4 grid)\n  - Current weight display above keypad\n  - Confirm (coral-red) and Cancel (gray) buttons at bottom\n  - Safe area insets: bottom: insets.bottom + Spacing.md\n- **Components:** Custom numeric keypad, decimal point support\n\n### 5. Alarm Management Screen\n- **Purpose:** View and manage all alarms\n- **Layout:**\n  - Default header with title \"Alarms\", left: Back, right: Add (plus icon)\n  - Scrollable list of alarm cards\n  - Empty state: \"No alarms set\" with illustration\n  - Safe area insets: top: Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **List Items:** Alarm time/pattern, sound icon, toggle switch, swipe-to-delete\n\n### 6. Add/Edit Alarm Screen\n- **Purpose:** Create or edit alarm with three modes\n- **Layout:**\n  - Default header, title: \"New Alarm\" or \"Edit Alarm\", left: Cancel, right: Save\n  - Scrollable form\n  - Safe area insets: top: Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **Form Sections:**\n  - Alarm mode selector (segmented control): One-time, Repeat, Duration Pattern\n  - Conditional inputs based on mode (time picker, interval input, pattern configuration)\n  - Sound/vibration toggles\n\n### 7. Weather Details Screen\n- **Purpose:** Comprehensive weather information\n- **Layout:**\n  - Default header, title: \"Weather\", left: Back, right: Refresh icon\n  - Scrollable content\n  - Last update timestamp at top\n  - Offline indicator banner when no connection\n  - Safe area insets: top: Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **Components:** Weather metric cards, pressure trend line chart, humidity/wind speed indicators\n\n### 8. End Match Summary Screen\n- **Purpose:** Review completed match data\n- **Layout:**\n  - Default header, title: \"Match Complete\", right: Share icon\n  - Scrollable content\n  - Bottom fixed buttons: \"Export\" and \"New Match\" (coral-red)\n  - Safe area insets: top: Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **Components:** Total weight card (large), per-net breakdown list, over-capacity warnings (red badges)\n\n### 9. Settings Screen\n- **Purpose:** App configuration\n- **Layout:**\n  - Default header, title: \"Settings\", left: Back\n  - Scrollable list with sections\n  - Safe area insets: top: Spacing.xl, bottom: insets.bottom + Spacing.xl\n- **Sections:** Profile (avatar, name), Units, Appearance (theme options), Sound/Haptics, Weather API Key\n\n### 10. Lock Mode Overlay\n- **Purpose:** Prevent accidental touches during match\n- **Layout:**\n  - Full-screen semi-transparent dark overlay\n  - Center: Large \"Locked\" text with padlock icon\n  - Bottom: \"Tap 3 times to unlock\" instruction\n  - Triple-tap gesture to dismiss\n\n## Design System\n\n### Color Palette\n**Primary (Coral Red):** `#FF6B5A` - CTAs, add buttons, progress warnings\n**Secondary (Teal Blue):** `#4ECDC4` - subtract buttons, accents, links\n**Background (Dark Navy):** `#1A2332` - app background\n**Surface (Charcoal):** `#2D3748` - cards, tiles, modals\n**Success (Green):** `#48BB78` - progress bars < 80%\n**Warning (Amber):** `#F6AD55` - progress bars 80-100%\n**Error (Red):** `#FC8181` - over-capacity, critical alerts\n**Text Primary:** `#FFFFFF` - main text\n**Text Secondary:** `#A0AEC0` - labels, metadata\n**Border:** `#4A5568` - dividers, input borders\n\n### Typography\n- **Heading 1 (Timer):** 48px, Bold, Tabular Numbers\n- **Heading 2 (Totals):** 32px, Bold\n- **Heading 3 (Section):** 20px, Semibold\n- **Body Large (Weight):** 24px, Medium\n- **Body:** 16px, Regular\n- **Caption:** 14px, Regular\n- **System Font:** Use platform default (SF Pro for iOS, Roboto for Android)\n\n### Component Specifications\n\n**Net Tile:**\n- Size: Flexible (fills 1/3 width × 1/2 height of grid)\n- Border radius: 12px\n- Background: Surface color\n- Padding: Spacing.md\n- Add/Subtract buttons: 44×44px circular, floating 8px from edges\n- Drop shadow on buttons: shadowOffset {width: 0, height: 2}, shadowOpacity: 0.10, shadowRadius: 2\n\n**Primary Button:**\n- Height: 56px\n- Border radius: 12px\n- Background: Primary color\n- Text: White, 16px, Semibold\n- Pressed state: Opacity 0.8 with haptic feedback\n\n**Progress Bar:**\n- Height: 4px\n- Border radius: 2px\n- Animated width change with easing\n- Color changes dynamically based on percentage\n\n**Haptic Feedback:**\n- Weight increment/decrement: Light impact\n- Button press: Selection feedback\n- Alarm trigger: Heavy impact\n- Match start/end: Success notification\n\n### Critical Assets\n1. **User Avatars (3 presets):** Stylized fishing-themed icons (angler, fish, hook) matching app aesthetic\n2. **Weather Icons:** Sun, cloud, rain, wind (use Feather icon set)\n3. **App Icon:** Based on provided PegPro logo\n\n### Accessibility\n- Minimum touch target: 44×44px\n- Text contrast ratio: 4.5:1 minimum\n- Support VoiceOver/TalkBack for screen readers\n- Large text support (Dynamic Type on iOS)\n- Haptic feedback as alternative to audio cues\n- Color is not sole indicator (use icons + color for progress states)","path":null,"size_bytes":8294,"size_tokens":null},"client/components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: theme.link,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: theme.buttonText }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":2014,"size_tokens":null},"client/components/Card.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable, ViewStyle } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  elevation?: number;\n  title?: string;\n  description?: string;\n  children?: React.ReactNode;\n  onPress?: () => void;\n  style?: ViewStyle;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({\n  elevation = 1,\n  title,\n  description,\n  children,\n  onPress,\n  style,\n}: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, springConfig);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, springConfig);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        animatedStyle,\n        style,\n      ]}\n    >\n      {title ? (\n        <ThemedText type=\"h4\" style={styles.cardTitle}>\n          {title}\n        </ThemedText>\n      ) : null}\n      {description ? (\n        <ThemedText type=\"small\" style={styles.cardDescription}>\n          {description}\n        </ThemedText>\n      ) : null}\n      {children}\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius[\"2xl\"],\n  },\n  cardTitle: {\n    marginBottom: Spacing.sm,\n  },\n  cardDescription: {\n    opacity: 0.7,\n  },\n});\n","path":null,"size_bytes":2437,"size_tokens":null},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction stripProtocol(domain) {\n  let urlString = domain.trim();\n\n  if (!/^https?:\\/\\//i.test(urlString)) {\n    urlString = `https://${urlString}`;\n  }\n\n  return new URL(urlString).host;\n}\n\nfunction getDeploymentDomain() {\n  // Check Replit deployment environment variables first\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    return stripProtocol(process.env.REPLIT_INTERNAL_APP_DOMAIN);\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    return stripProtocol(process.env.REPLIT_DEV_DOMAIN);\n  }\n\n  if (process.env.EXPO_PUBLIC_DOMAIN) {\n    return stripProtocol(process.env.EXPO_PUBLIC_DOMAIN);\n  }\n\n  console.error(\n    \"ERROR: No deployment domain found. Set REPLIT_INTERNAL_APP_DOMAIN, REPLIT_DEV_DOMAIN, or EXPO_PUBLIC_DOMAIN\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\", {\n      signal: AbortSignal.timeout(5000),\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro(expoPublicDomain) {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    console.log(\"Metro already running\");\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  console.log(`Setting EXPO_PUBLIC_DOMAIN=${expoPublicDomain}`);\n  const env = {\n    ...process.env,\n    EXPO_PUBLIC_DOMAIN: expoPublicDomain,\n  };\n  metroProcess = spawn(\"npm\", [\"run\", \"expo:start:static:build\"], {\n    stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    detached: false,\n    env,\n  });\n\n  if (metroProcess.stdout) {\n    metroProcess.stdout.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.log(`[Metro] ${output}`);\n    });\n  }\n  if (metroProcess.stderr) {\n    metroProcess.stderr.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.error(`[Metro Error] ${output}`);\n    });\n  }\n\n  for (let i = 0; i < 60; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 120_000);\n\n  try {\n    console.log(`Downloading: ${url}`);\n    const response = await fetch(url, { signal: controller.signal });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n\n    if (error.name === \"AbortError\") {\n      throw new Error(`Download timeout after 2m: ${url}`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/client/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  console.log(`Fetching ${platform} bundle...`);\n  await downloadFile(url.toString(), output);\n  console.log(`${platform} bundle ready`);\n}\n\nasync function downloadManifest(platform) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 300_000);\n\n  try {\n    console.log(`Fetching ${platform} manifest...`);\n    const response = await fetch(\"http://localhost:8081/manifest\", {\n      headers: { \"expo-platform\": platform },\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const manifest = await response.json();\n    console.log(`${platform} manifest ready`);\n    return manifest;\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      throw new Error(\n        `Manifest download timeout after 5m for platform: ${platform}`,\n      );\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n  console.log(\"This may take several minutes for production builds...\");\n\n  try {\n    const results = await Promise.allSettled([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n\n    const failures = results\n      .map((result, index) => ({ result, index }))\n      .filter(({ result }) => result.status === \"rejected\");\n\n    if (failures.length > 0) {\n      const errorMessages = failures.map(({ result, index }) => {\n        const names = [\n          \"iOS bundle\",\n          \"Android bundle\",\n          \"iOS manifest\",\n          \"Android manifest\",\n        ];\n        return `  - ${names[index]}: ${result.reason?.message || result.reason}`;\n      });\n\n      exitWithError(`Download failed:\\n${errorMessages.join(\"\\n\")}`);\n    }\n\n    const iosManifest =\n      results[2].status === \"fulfilled\" ? results[2].value : null;\n    const androidManifest =\n      results[3].status === \"fulfilled\" ? results[3].value : null;\n\n    console.log(\"All downloads completed successfully\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Unexpected download error: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath);\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath);\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath);\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n\n  const domain = getDeploymentDomain();\n  const baseUrl = `https://${domain}`;\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro(domain);\n\n  const downloadTimeout = 300000;\n  const downloadPromise = downloadBundlesAndManifests(timestamp);\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(\n        new Error(\n          `Overall download timeout after ${downloadTimeout / 1000} seconds. ` +\n            \"Metro may be struggling to generate bundles. Check Metro logs above.\",\n        ),\n      );\n    }, downloadTimeout);\n  });\n\n  const manifests = await Promise.race([downloadPromise, timeoutPromise]);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","path":null,"size_bytes":14884,"size_tokens":null},"client/hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","path":null,"size_bytes":47,"size_tokens":null},"client/components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":832,"size_tokens":null},"client/hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","path":null,"size_bytes":480,"size_tokens":null},"client/screens/AddEditAlarmScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from \"react\";\nimport { View, StyleSheet, Pressable, Switch, TextInput, ScrollView, Platform } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation, useRoute, RouteProp } from \"@react-navigation/native\";\nimport * as Haptics from \"expo-haptics\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { KeyboardAwareScrollViewCompat } from \"@/components/KeyboardAwareScrollViewCompat\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { AlarmMode } from \"@/lib/types\";\n\ntype RouteType = RouteProp<RootStackParamList, \"AddEditAlarm\">;\n\nconst ALARM_MODES: { value: AlarmMode; label: string; icon: string }[] = [\n  { value: \"one-time\", label: \"One-time\", icon: \"clock\" },\n  { value: \"repeat\", label: \"Repeat\", icon: \"repeat\" },\n];\n\nconst HOURS = Array.from({ length: 24 }, (_, i) => i);\nconst MINUTES = Array.from({ length: 60 }, (_, i) => i);\n\nexport default function AddEditAlarmScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const navigation = useNavigation();\n  const route = useRoute<RouteType>();\n  const { theme } = useTheme();\n  const { alarms, addAlarm, updateAlarm, settings } = useApp();\n\n  const alarmId = route.params?.alarmId;\n  const existingAlarm = alarmId ? alarms.find((a) => a.id === alarmId) : null;\n  const isEditing = !!existingAlarm;\n\n  const getInitialTime = () => {\n    if (existingAlarm?.time) {\n      const date = new Date(existingAlarm.time);\n      return { hour: date.getHours(), minute: date.getMinutes() };\n    }\n    const now = new Date();\n    now.setHours(now.getHours() + 1);\n    return { hour: now.getHours(), minute: 0 };\n  };\n\n  const initialTime = getInitialTime();\n  const [originalAlarmTime] = useState(existingAlarm?.time || null);\n\n  const [mode, setMode] = useState<AlarmMode>(existingAlarm?.mode || \"repeat\");\n  const [label, setLabel] = useState(existingAlarm?.label || \"\");\n  const [selectedHour, setSelectedHour] = useState(initialTime.hour);\n  const [selectedMinute, setSelectedMinute] = useState(initialTime.minute);\n  const [intervalMinutes, setIntervalMinutes] = useState(\n    existingAlarm?.intervalMinutes?.toString() || \"30\"\n  );\n  const [durationSeconds, setDurationSeconds] = useState(\n    existingAlarm?.durationSeconds?.toString() || \"20\"\n  );\n  const [patternMinutes, setPatternMinutes] = useState(\n    existingAlarm?.patternMinutes?.toString() || \"5\"\n  );\n  const [soundEnabled, setSoundEnabled] = useState(existingAlarm?.soundEnabled ?? true);\n  const [vibrationEnabled, setVibrationEnabled] = useState(existingAlarm?.vibrationEnabled ?? true);\n\n  const handleSavePress = useCallback(() => {\n    handleSave();\n  }, [mode, label, selectedHour, selectedMinute, intervalMinutes, durationSeconds, patternMinutes, soundEnabled, vibrationEnabled, isEditing, alarmId]);\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      headerTitle: isEditing ? \"Edit Alarm\" : \"New Alarm\",\n      headerLeft: () => (\n        <Pressable\n          onPress={() => navigation.goBack()}\n          hitSlop={8}\n          style={({ pressed }) => ({ opacity: pressed ? 0.6 : 1 })}\n        >\n          <ThemedText type=\"body\" style={{ color: theme.link }}>Cancel</ThemedText>\n        </Pressable>\n      ),\n      headerRight: () => (\n        <Pressable\n          onPress={handleSavePress}\n          hitSlop={8}\n          style={({ pressed }) => ({ opacity: pressed ? 0.6 : 1 })}\n        >\n          <ThemedText type=\"body\" style={{ color: Colors.dark.primary, fontWeight: \"600\" }}>\n            Save\n          </ThemedText>\n        </Pressable>\n      ),\n    });\n  }, [navigation, theme, handleSavePress]);\n\n  const getAlarmTime = () => {\n    const now = new Date();\n    let alarmDate: Date;\n    \n    if (originalAlarmTime && isEditing) {\n      alarmDate = new Date(originalAlarmTime);\n      alarmDate.setHours(selectedHour, selectedMinute, 0, 0);\n      if (alarmDate <= now) {\n        alarmDate.setDate(now.getDate());\n        alarmDate.setHours(selectedHour, selectedMinute, 0, 0);\n        if (alarmDate <= now) {\n          alarmDate.setDate(alarmDate.getDate() + 1);\n        }\n      }\n    } else {\n      alarmDate = new Date();\n      alarmDate.setHours(selectedHour, selectedMinute, 0, 0);\n      if (alarmDate <= now) {\n        alarmDate.setDate(alarmDate.getDate() + 1);\n      }\n    }\n    \n    return alarmDate.getTime();\n  };\n\n  const handleSave = async () => {\n    const alarmData = {\n      mode,\n      label: label.trim() || undefined,\n      intervalMinutes: mode === \"repeat\" ? parseInt(intervalMinutes) || 30 : undefined,\n      durationSeconds: undefined,\n      patternMinutes: undefined,\n      time: (mode === \"one-time\" || mode === \"repeat\") ? getAlarmTime() : undefined,\n      soundEnabled,\n      vibrationEnabled,\n      enabled: true,\n    };\n\n    if (isEditing && alarmId) {\n      await updateAlarm(alarmId, alarmData);\n    } else {\n      await addAlarm(alarmData);\n    }\n\n    if (settings.haptics) {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n    }\n\n    navigation.goBack();\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <KeyboardAwareScrollViewCompat\n        contentContainerStyle={[\n          styles.content,\n          {\n            paddingTop: headerHeight + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl,\n          },\n        ]}\n      >\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Alarm Type\n          </ThemedText>\n          <View style={styles.modeSelector}>\n            {ALARM_MODES.map((m) => (\n              <Pressable\n                key={m.value}\n                onPress={() => setMode(m.value)}\n                style={[\n                  styles.modeOption,\n                  {\n                    backgroundColor: mode === m.value ? Colors.dark.primary : theme.backgroundDefault,\n                    borderColor: mode === m.value ? Colors.dark.primary : theme.border,\n                  },\n                ]}\n              >\n                <Feather\n                  name={m.icon as any}\n                  size={20}\n                  color={mode === m.value ? \"#FFFFFF\" : theme.text}\n                />\n                <ThemedText\n                  type=\"small\"\n                  style={{\n                    color: mode === m.value ? \"#FFFFFF\" : theme.text,\n                    marginTop: 4,\n                    fontWeight: \"600\",\n                  }}\n                >\n                  {m.label}\n                </ThemedText>\n              </Pressable>\n            ))}\n          </View>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Label (optional)\n          </ThemedText>\n          <TextInput\n            style={[\n              styles.textInput,\n              { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n            ]}\n            placeholder=\"e.g., Feed time\"\n            placeholderTextColor={theme.textSecondary}\n            value={label}\n            onChangeText={setLabel}\n          />\n        </View>\n\n        {mode === \"repeat\" ? (\n          <>\n            <View style={styles.section}>\n              <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n                Start Time\n              </ThemedText>\n              <View style={styles.timePickerContainer}>\n                <View style={[styles.timePickerColumn, { backgroundColor: theme.backgroundDefault, borderColor: theme.border }]}>\n                  <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginBottom: Spacing.xs }}>Hour</ThemedText>\n                  <View style={styles.timeButtonsRow}>\n                    <Pressable\n                      onPress={() => setSelectedHour((prev) => (prev === 0 ? 23 : prev - 1))}\n                      style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                    >\n                      <Feather name=\"chevron-up\" size={20} color={theme.text} />\n                    </Pressable>\n                    <ThemedText type=\"h2\" style={styles.timeValue}>\n                      {selectedHour.toString().padStart(2, \"0\")}\n                    </ThemedText>\n                    <Pressable\n                      onPress={() => setSelectedHour((prev) => (prev === 23 ? 0 : prev + 1))}\n                      style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                    >\n                      <Feather name=\"chevron-down\" size={20} color={theme.text} />\n                    </Pressable>\n                  </View>\n                </View>\n\n                <ThemedText type=\"h2\" style={{ marginHorizontal: Spacing.sm }}>:</ThemedText>\n\n                <View style={[styles.timePickerColumn, { backgroundColor: theme.backgroundDefault, borderColor: theme.border }]}>\n                  <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginBottom: Spacing.xs }}>Minute</ThemedText>\n                  <View style={styles.timeButtonsRow}>\n                    <Pressable\n                      onPress={() => setSelectedMinute((prev) => (prev === 0 ? 59 : prev - 1))}\n                      style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                    >\n                      <Feather name=\"chevron-up\" size={20} color={theme.text} />\n                    </Pressable>\n                    <ThemedText type=\"h2\" style={styles.timeValue}>\n                      {selectedMinute.toString().padStart(2, \"0\")}\n                    </ThemedText>\n                    <Pressable\n                      onPress={() => setSelectedMinute((prev) => (prev === 59 ? 0 : prev + 1))}\n                      style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                    >\n                      <Feather name=\"chevron-down\" size={20} color={theme.text} />\n                    </Pressable>\n                  </View>\n                </View>\n              </View>\n              <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginTop: Spacing.sm, textAlign: \"center\" }}>\n                First alarm at {selectedHour.toString().padStart(2, \"0\")}:{selectedMinute.toString().padStart(2, \"0\")}\n              </ThemedText>\n            </View>\n\n            <View style={styles.section}>\n              <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n                Repeat Every (minutes)\n              </ThemedText>\n              <TextInput\n                style={[\n                  styles.textInput,\n                  { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n                ]}\n                keyboardType=\"number-pad\"\n                value={intervalMinutes}\n                onChangeText={setIntervalMinutes}\n                placeholder=\"30\"\n                placeholderTextColor={theme.textSecondary}\n              />\n            </View>\n          </>\n        ) : null}\n\n        {mode === \"duration-pattern\" ? (\n          <>\n            <View style={styles.section}>\n              <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n                Duration (seconds)\n              </ThemedText>\n              <TextInput\n                style={[\n                  styles.textInput,\n                  { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n                ]}\n                keyboardType=\"number-pad\"\n                value={durationSeconds}\n                onChangeText={setDurationSeconds}\n                placeholder=\"20\"\n                placeholderTextColor={theme.textSecondary}\n              />\n              <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginTop: Spacing.xs }}>\n                How long to feed/act\n              </ThemedText>\n            </View>\n\n            <View style={styles.section}>\n              <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n                Every (minutes)\n              </ThemedText>\n              <TextInput\n                style={[\n                  styles.textInput,\n                  { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n                ]}\n                keyboardType=\"number-pad\"\n                value={patternMinutes}\n                onChangeText={setPatternMinutes}\n                placeholder=\"5\"\n                placeholderTextColor={theme.textSecondary}\n              />\n              <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginTop: Spacing.xs }}>\n                Interval between each reminder\n              </ThemedText>\n            </View>\n          </>\n        ) : null}\n\n        {mode === \"one-time\" ? (\n          <View style={styles.section}>\n            <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n              Set Time\n            </ThemedText>\n            <View style={styles.timePickerContainer}>\n              <View style={[styles.timePickerColumn, { backgroundColor: theme.backgroundDefault, borderColor: theme.border }]}>\n                <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginBottom: Spacing.xs }}>Hour</ThemedText>\n                <View style={styles.timeButtonsRow}>\n                  <Pressable\n                    onPress={() => setSelectedHour((prev) => (prev === 0 ? 23 : prev - 1))}\n                    style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                  >\n                    <Feather name=\"chevron-up\" size={20} color={theme.text} />\n                  </Pressable>\n                  <ThemedText type=\"h2\" style={styles.timeValue}>\n                    {selectedHour.toString().padStart(2, \"0\")}\n                  </ThemedText>\n                  <Pressable\n                    onPress={() => setSelectedHour((prev) => (prev === 23 ? 0 : prev + 1))}\n                    style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                  >\n                    <Feather name=\"chevron-down\" size={20} color={theme.text} />\n                  </Pressable>\n                </View>\n              </View>\n\n              <ThemedText type=\"h2\" style={{ marginHorizontal: Spacing.sm }}>:</ThemedText>\n\n              <View style={[styles.timePickerColumn, { backgroundColor: theme.backgroundDefault, borderColor: theme.border }]}>\n                <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginBottom: Spacing.xs }}>Minute</ThemedText>\n                <View style={styles.timeButtonsRow}>\n                  <Pressable\n                    onPress={() => setSelectedMinute((prev) => (prev === 0 ? 59 : prev - 1))}\n                    style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                  >\n                    <Feather name=\"chevron-up\" size={20} color={theme.text} />\n                  </Pressable>\n                  <ThemedText type=\"h2\" style={styles.timeValue}>\n                    {selectedMinute.toString().padStart(2, \"0\")}\n                  </ThemedText>\n                  <Pressable\n                    onPress={() => setSelectedMinute((prev) => (prev === 59 ? 0 : prev + 1))}\n                    style={[styles.timeButton, { backgroundColor: theme.backgroundTertiary }]}\n                  >\n                    <Feather name=\"chevron-down\" size={20} color={theme.text} />\n                  </Pressable>\n                </View>\n              </View>\n            </View>\n            <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginTop: Spacing.sm, textAlign: \"center\" }}>\n              Alarm will trigger at {selectedHour.toString().padStart(2, \"0\")}:{selectedMinute.toString().padStart(2, \"0\")}\n            </ThemedText>\n          </View>\n        ) : null}\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Notifications\n          </ThemedText>\n\n          <View style={styles.switchRow}>\n            <View style={styles.switchLabel}>\n              <Feather name=\"volume-2\" size={20} color={theme.textSecondary} />\n              <ThemedText type=\"body\" style={{ marginLeft: Spacing.sm }}>Sound</ThemedText>\n            </View>\n            <Switch\n              value={soundEnabled}\n              onValueChange={setSoundEnabled}\n              trackColor={{ false: theme.border, true: Colors.dark.primary }}\n              thumbColor=\"#FFFFFF\"\n            />\n          </View>\n\n          <View style={styles.switchRow}>\n            <View style={styles.switchLabel}>\n              <Feather name=\"smartphone\" size={20} color={theme.textSecondary} />\n              <ThemedText type=\"body\" style={{ marginLeft: Spacing.sm }}>Vibration</ThemedText>\n            </View>\n            <Switch\n              value={vibrationEnabled}\n              onValueChange={setVibrationEnabled}\n              trackColor={{ false: theme.border, true: Colors.dark.primary }}\n              thumbColor=\"#FFFFFF\"\n            />\n          </View>\n        </View>\n      </KeyboardAwareScrollViewCompat>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  label: {\n    marginBottom: Spacing.sm,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n  },\n  modeSelector: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  modeOption: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderWidth: 1,\n  },\n  textInput: {\n    height: 52,\n    borderRadius: BorderRadius.sm,\n    paddingHorizontal: Spacing.lg,\n    borderWidth: 1,\n    ...Typography.body,\n  },\n  infoCard: {\n    flexDirection: \"row\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.xl,\n  },\n  timePickerContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  timePickerColumn: {\n    alignItems: \"center\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    minWidth: 100,\n  },\n  timeButtonsRow: {\n    alignItems: \"center\",\n  },\n  timeButton: {\n    width: 44,\n    height: 36,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  timeValue: {\n    marginVertical: Spacing.sm,\n  },\n  switchRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingVertical: Spacing.md,\n  },\n  switchLabel: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n});\n","path":null,"size_bytes":19305,"size_tokens":null},"client/lib/types.ts":{"content":"export type WeightUnit = \"lb/oz\" | \"kg/g\";\n\nexport interface NetData {\n  weight: number;\n  capacity?: number;\n}\n\nexport interface MatchConfig {\n  name: string;\n  durationMinutes: number;\n  pegNumber: string;\n  numberOfNets: number;\n  netCapacity?: number;\n  unit: WeightUnit;\n  keepScreenOn: boolean;\n}\n\nexport interface MatchState {\n  id: string;\n  config: MatchConfig;\n  startTime: number;\n  endTime?: number;\n  nets: NetData[];\n  isActive: boolean;\n}\n\nexport type AlarmMode = \"one-time\" | \"repeat\" | \"duration-pattern\";\n\nexport interface Alarm {\n  id: string;\n  mode: AlarmMode;\n  time?: number;\n  intervalMinutes?: number;\n  durationSeconds?: number;\n  patternMinutes?: number;\n  soundEnabled: boolean;\n  vibrationEnabled: boolean;\n  enabled: boolean;\n  label?: string;\n}\n\nexport interface WeatherData {\n  temperature: number;\n  humidity: number;\n  windSpeed: number;\n  pressure: number;\n  pressureTrend: \"rising\" | \"falling\" | \"stable\";\n  description: string;\n  lastUpdated: number;\n  isOffline?: boolean;\n}\n\nexport interface AppSettings {\n  unit: WeightUnit;\n  haptics: boolean;\n  sound: boolean;\n  displayName: string;\n  avatarPreset: number;\n  onboardingComplete: boolean;\n}\n\nexport const DEFAULT_SETTINGS: AppSettings = {\n  unit: \"lb/oz\",\n  haptics: true,\n  sound: true,\n  displayName: \"Angler\",\n  avatarPreset: 0,\n  onboardingComplete: false,\n};\n","path":null,"size_bytes":1356,"size_tokens":null},"client/components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","path":null,"size_bytes":1674,"size_tokens":null},"client/screens/AlarmManagementScreen.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable, FlatList, Switch } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport Animated, { FadeInRight, FadeOutLeft } from \"react-native-reanimated\";\nimport * as Haptics from \"expo-haptics\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Card } from \"@/components/Card\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { Alarm } from \"@/lib/types\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nexport default function AlarmManagementScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const navigation = useNavigation<NavigationProp>();\n  const { theme } = useTheme();\n  const { alarms, updateAlarm, deleteAlarm, settings } = useApp();\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      headerRight: () => (\n        <Pressable\n          onPress={() => navigation.navigate(\"AddEditAlarm\", {})}\n          hitSlop={8}\n          style={({ pressed }) => ({ opacity: pressed ? 0.6 : 1 })}\n        >\n          <Feather name=\"plus\" size={22} color={theme.text} />\n        </Pressable>\n      ),\n    });\n  }, [navigation, theme]);\n\n  const handleToggleAlarm = (alarm: Alarm) => {\n    updateAlarm(alarm.id, { enabled: !alarm.enabled });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const handleDeleteAlarm = (id: string) => {\n    deleteAlarm(id);\n    if (settings.haptics) {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n    }\n  };\n\n  const getAlarmDescription = (alarm: Alarm): string => {\n    switch (alarm.mode) {\n      case \"one-time\":\n        if (alarm.time) {\n          const date = new Date(alarm.time);\n          return `At ${date.toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" })}`;\n        }\n        return \"One-time alarm\";\n      case \"repeat\":\n        return `Every ${alarm.intervalMinutes} min`;\n      case \"duration-pattern\":\n        return `${alarm.durationSeconds}s every ${alarm.patternMinutes} min`;\n      default:\n        return \"Alarm\";\n    }\n  };\n\n  const renderAlarm = ({ item }: { item: Alarm }) => (\n    <Animated.View entering={FadeInRight} exiting={FadeOutLeft}>\n      <Card\n        elevation={1}\n        style={styles.alarmCard}\n        onPress={() => navigation.navigate(\"AddEditAlarm\", { alarmId: item.id })}\n      >\n        <View style={styles.alarmContent}>\n          <View style={styles.alarmInfo}>\n            <View style={styles.alarmIcons}>\n              {item.soundEnabled ? (\n                <Feather name=\"volume-2\" size={16} color={theme.textSecondary} />\n              ) : null}\n              {item.vibrationEnabled ? (\n                <Feather name=\"smartphone\" size={16} color={theme.textSecondary} />\n              ) : null}\n            </View>\n            <ThemedText type=\"body\" style={{ fontWeight: \"600\" }}>\n              {item.label || getAlarmDescription(item)}\n            </ThemedText>\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginTop: 2 }}>\n              {getAlarmDescription(item)}\n            </ThemedText>\n          </View>\n          <View style={styles.alarmActions}>\n            <Switch\n              value={item.enabled}\n              onValueChange={() => handleToggleAlarm(item)}\n              trackColor={{ false: theme.border, true: Colors.dark.primary }}\n              thumbColor=\"#FFFFFF\"\n            />\n            <Pressable\n              onPress={() => handleDeleteAlarm(item.id)}\n              hitSlop={8}\n              style={({ pressed }) => [styles.deleteButton, { opacity: pressed ? 0.6 : 1 }]}\n            >\n              <Feather name=\"trash-2\" size={18} color={Colors.dark.error} />\n            </Pressable>\n          </View>\n        </View>\n      </Card>\n    </Animated.View>\n  );\n\n  const renderEmpty = () => (\n    <View style={styles.emptyState}>\n      <View style={[styles.emptyIcon, { backgroundColor: theme.backgroundDefault }]}>\n        <Feather name=\"bell-off\" size={48} color={theme.textSecondary} />\n      </View>\n      <ThemedText type=\"h4\" style={{ marginTop: Spacing.xl }}>\n        No Alarms Set\n      </ThemedText>\n      <ThemedText\n        type=\"small\"\n        style={{ color: theme.textSecondary, marginTop: Spacing.sm, textAlign: \"center\" }}\n      >\n        Tap the + button to add reminders for feeding times or match intervals\n      </ThemedText>\n      <Pressable\n        onPress={() => navigation.navigate(\"AddEditAlarm\", {})}\n        style={({ pressed }) => [\n          styles.addButton,\n          { backgroundColor: Colors.dark.primary, opacity: pressed ? 0.8 : 1 },\n        ]}\n      >\n        <Feather name=\"plus\" size={20} color=\"#FFFFFF\" />\n        <ThemedText type=\"body\" style={{ color: \"#FFFFFF\", marginLeft: Spacing.sm, fontWeight: \"600\" }}>\n          Add Alarm\n        </ThemedText>\n      </Pressable>\n    </View>\n  );\n\n  return (\n    <ThemedView style={styles.container}>\n      <FlatList\n        data={alarms}\n        keyExtractor={(item) => item.id}\n        renderItem={renderAlarm}\n        contentContainerStyle={[\n          styles.list,\n          {\n            paddingTop: headerHeight + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl,\n          },\n        ]}\n        ListEmptyComponent={renderEmpty}\n        showsVerticalScrollIndicator={false}\n      />\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  list: {\n    paddingHorizontal: Spacing.xl,\n    flexGrow: 1,\n  },\n  alarmCard: {\n    marginBottom: Spacing.sm,\n    padding: Spacing.lg,\n  },\n  alarmContent: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n  },\n  alarmInfo: {\n    flex: 1,\n  },\n  alarmIcons: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.xs,\n  },\n  alarmActions: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  deleteButton: {\n    padding: Spacing.xs,\n  },\n  emptyState: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingHorizontal: Spacing[\"2xl\"],\n  },\n  emptyIcon: {\n    width: 96,\n    height: 96,\n    borderRadius: BorderRadius.lg,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  addButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    marginTop: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":6958,"size_tokens":null},"client/screens/MatchSetupScreen.tsx":{"content":"import React, { useState } from \"react\";\nimport { View, StyleSheet, Pressable, Switch, TextInput } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { KeyboardAwareScrollViewCompat } from \"@/components/KeyboardAwareScrollViewCompat\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { WeightUnit, MatchConfig } from \"@/lib/types\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nexport default function MatchSetupScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const navigation = useNavigation<NavigationProp>();\n  const { theme } = useTheme();\n  const { settings, startMatch } = useApp();\n\n  const [matchName, setMatchName] = useState(\"\");\n  const [hours, setHours] = useState(\"5\");\n  const [minutes, setMinutes] = useState(\"0\");\n  const [pegNumber, setPegNumber] = useState(\"\");\n  const [numberOfNets, setNumberOfNets] = useState(4);\n  const [netCapacity, setNetCapacity] = useState(\"\");\n  const [unit, setUnit] = useState<WeightUnit>(settings.unit);\n  const [keepScreenOn, setKeepScreenOn] = useState(true);\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      headerRight: () => null,\n    });\n  }, [navigation, theme]);\n\n  const handleStartMatch = async () => {\n    const durationMinutes = parseInt(hours) * 60 + parseInt(minutes);\n    let capacityInGrams: number | undefined;\n    if (netCapacity) {\n      const capacityValue = parseFloat(netCapacity);\n      if (unit === \"lb/oz\") {\n        capacityInGrams = capacityValue * 16 * 28.3495;\n      } else {\n        capacityInGrams = capacityValue;\n      }\n    }\n    const config: MatchConfig = {\n      name: matchName || `Match ${new Date().toLocaleDateString()}`,\n      durationMinutes: durationMinutes || 300,\n      pegNumber: pegNumber || \"1\",\n      numberOfNets,\n      netCapacity: capacityInGrams,\n      unit,\n      keepScreenOn,\n    };\n    await startMatch(config);\n    navigation.replace(\"LiveMatch\");\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <KeyboardAwareScrollViewCompat\n        contentContainerStyle={[\n          styles.content,\n          {\n            paddingTop: headerHeight + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl + 80,\n          },\n        ]}\n      >\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Match Name\n          </ThemedText>\n          <TextInput\n            style={[\n              styles.textInput,\n              { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n            ]}\n            placeholder=\"e.g., Sunday Open Match\"\n            placeholderTextColor={theme.textSecondary}\n            value={matchName}\n            onChangeText={setMatchName}\n          />\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Match Duration\n          </ThemedText>\n          <View style={styles.durationRow}>\n            <View style={styles.durationInput}>\n              <TextInput\n                style={[\n                  styles.numberInput,\n                  { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n                ]}\n                keyboardType=\"number-pad\"\n                value={hours}\n                onChangeText={setHours}\n                maxLength={2}\n              />\n              <ThemedText type=\"small\" style={{ color: theme.textSecondary }}>hours</ThemedText>\n            </View>\n            <View style={styles.durationInput}>\n              <TextInput\n                style={[\n                  styles.numberInput,\n                  { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n                ]}\n                keyboardType=\"number-pad\"\n                value={minutes}\n                onChangeText={setMinutes}\n                maxLength={2}\n              />\n              <ThemedText type=\"small\" style={{ color: theme.textSecondary }}>mins</ThemedText>\n            </View>\n          </View>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Peg Number\n          </ThemedText>\n          <TextInput\n            style={[\n              styles.textInput,\n              { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n            ]}\n            placeholder=\"e.g., 42\"\n            placeholderTextColor={theme.textSecondary}\n            keyboardType=\"number-pad\"\n            value={pegNumber}\n            onChangeText={setPegNumber}\n          />\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Number of Nets\n          </ThemedText>\n          <View style={styles.netSelector}>\n            {[1, 2, 3, 4, 5, 6].map((n) => (\n              <Pressable\n                key={n}\n                onPress={() => setNumberOfNets(n)}\n                style={[\n                  styles.netOption,\n                  {\n                    backgroundColor: numberOfNets === n ? Colors.dark.primary : theme.backgroundDefault,\n                    borderColor: numberOfNets === n ? Colors.dark.primary : theme.border,\n                  },\n                ]}\n              >\n                <ThemedText\n                  type=\"body\"\n                  style={{ color: numberOfNets === n ? \"#FFFFFF\" : theme.text, fontWeight: \"600\" }}\n                >\n                  {n}\n                </ThemedText>\n              </Pressable>\n            ))}\n          </View>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Per-Net Capacity (optional)\n          </ThemedText>\n          <TextInput\n            style={[\n              styles.textInput,\n              { backgroundColor: theme.backgroundDefault, color: theme.text, borderColor: theme.border },\n            ]}\n            placeholder={unit === \"kg/g\" ? \"e.g., 25000 (grams)\" : \"e.g., 50 (pounds)\"}\n            placeholderTextColor={theme.textSecondary}\n            keyboardType=\"decimal-pad\"\n            value={netCapacity}\n            onChangeText={setNetCapacity}\n          />\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.label, { color: theme.textSecondary }]}>\n            Weight Units\n          </ThemedText>\n          <View style={styles.unitToggle}>\n            <Pressable\n              onPress={() => setUnit(\"lb/oz\")}\n              style={[\n                styles.unitOption,\n                {\n                  backgroundColor: unit === \"lb/oz\" ? Colors.dark.primary : theme.backgroundDefault,\n                  borderColor: unit === \"lb/oz\" ? Colors.dark.primary : theme.border,\n                },\n              ]}\n            >\n              <ThemedText\n                type=\"body\"\n                style={{ color: unit === \"lb/oz\" ? \"#FFFFFF\" : theme.text, fontWeight: \"600\" }}\n              >\n                lb / oz\n              </ThemedText>\n            </Pressable>\n            <Pressable\n              onPress={() => setUnit(\"kg/g\")}\n              style={[\n                styles.unitOption,\n                {\n                  backgroundColor: unit === \"kg/g\" ? Colors.dark.primary : theme.backgroundDefault,\n                  borderColor: unit === \"kg/g\" ? Colors.dark.primary : theme.border,\n                },\n              ]}\n            >\n              <ThemedText\n                type=\"body\"\n                style={{ color: unit === \"kg/g\" ? \"#FFFFFF\" : theme.text, fontWeight: \"600\" }}\n              >\n                kg / g\n              </ThemedText>\n            </Pressable>\n          </View>\n        </View>\n\n        <View style={styles.switchRow}>\n          <View style={styles.switchLabel}>\n            <Feather name=\"monitor\" size={20} color={theme.textSecondary} />\n            <ThemedText type=\"body\" style={{ marginLeft: Spacing.sm }}>\n              Keep Screen On\n            </ThemedText>\n          </View>\n          <Switch\n            value={keepScreenOn}\n            onValueChange={setKeepScreenOn}\n            trackColor={{ false: theme.border, true: Colors.dark.primary }}\n            thumbColor=\"#FFFFFF\"\n          />\n        </View>\n      </KeyboardAwareScrollViewCompat>\n\n      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing.lg }]}>\n        <Pressable\n          onPress={handleStartMatch}\n          style={({ pressed }) => [\n            styles.startButton,\n            { backgroundColor: Colors.dark.primary, opacity: pressed ? 0.8 : 1 },\n          ]}\n        >\n          <Feather name=\"play\" size={22} color={Colors.dark.buttonTextDark} />\n          <ThemedText type=\"body\" style={[styles.startButtonText, { color: Colors.dark.buttonTextDark }]}>\n            Start Match\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  label: {\n    marginBottom: Spacing.sm,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n  },\n  textInput: {\n    height: 52,\n    borderRadius: BorderRadius.sm,\n    paddingHorizontal: Spacing.lg,\n    borderWidth: 1,\n    ...Typography.body,\n  },\n  durationRow: {\n    flexDirection: \"row\",\n    gap: Spacing.lg,\n  },\n  durationInput: {\n    flex: 1,\n    alignItems: \"center\",\n  },\n  numberInput: {\n    width: \"100%\",\n    height: 52,\n    borderRadius: BorderRadius.sm,\n    paddingHorizontal: Spacing.lg,\n    borderWidth: 1,\n    textAlign: \"center\",\n    marginBottom: Spacing.xs,\n    ...Typography.body,\n  },\n  netSelector: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  netOption: {\n    flex: 1,\n    height: 48,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderWidth: 1,\n  },\n  unitToggle: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  unitOption: {\n    flex: 1,\n    height: 48,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderWidth: 1,\n  },\n  switchRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingVertical: Spacing.md,\n  },\n  switchLabel: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  footer: {\n    position: \"absolute\",\n    bottom: 0,\n    left: 0,\n    right: 0,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n    backgroundColor: Colors.dark.backgroundRoot,\n  },\n  startButton: {\n    height: 56,\n    borderRadius: BorderRadius.sm,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.sm,\n  },\n  startButtonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":11635,"size_tokens":null},"client/components/KeyboardAwareScrollViewCompat.tsx":{"content":"import { Platform, ScrollView, ScrollViewProps } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\n\ntype Props = KeyboardAwareScrollViewProps & ScrollViewProps;\n\n/**\n * KeyboardAwareScrollView that falls back to ScrollView on web.\n * Use this for any screen containing text inputs.\n */\nexport function KeyboardAwareScrollViewCompat({\n  children,\n  keyboardShouldPersistTaps = \"handled\",\n  ...props\n}: Props) {\n  if (Platform.OS === \"web\") {\n    return (\n      <ScrollView\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        {...props}\n      >\n        {children}\n      </ScrollView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollView\n      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n      {...props}\n    >\n      {children}\n    </KeyboardAwareScrollView>\n  );\n}\n","path":null,"size_bytes":872,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"node:http\";\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // put application routes here\n  // prefix all routes with /api\n\n  const httpServer = createServer(app);\n\n  return httpServer;\n}\n","path":null,"size_bytes":297,"size_tokens":null},"client/hooks/useScreenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface UseScreenOptionsParams {\n  transparent?: boolean;\n}\n\nexport function useScreenOptions({\n  transparent = true,\n}: UseScreenOptionsParams = {}): NativeStackNavigationOptions {\n  const { theme, isDark } = useTheme();\n\n  return {\n    headerTitleAlign: \"center\",\n    headerTransparent: transparent,\n    headerBlurEffect: isDark ? \"dark\" : \"light\",\n    headerTintColor: theme.text,\n    headerStyle: {\n      backgroundColor: Platform.select({\n        ios: undefined,\n        android: theme.backgroundRoot,\n        web: theme.backgroundRoot,\n      }),\n    },\n    gestureEnabled: true,\n    gestureDirection: \"horizontal\",\n    fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n    contentStyle: {\n      backgroundColor: theme.backgroundRoot,\n    },\n  };\n}\n","path":null,"size_bytes":1000,"size_tokens":null},"client/screens/OnboardingScreen.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable, Image } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport Animated, { FadeInDown } from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Card } from \"@/components/Card\";\nimport { Button } from \"@/components/Button\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\nconst logoImage = require(\"../../attached_assets/company_logo.jpg\");\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nconst features = [\n  {\n    icon: \"clock\" as const,\n    title: \"Match Timer\",\n    description: \"Track your match duration with precision countdown timer\",\n  },\n  {\n    icon: \"grid\" as const,\n    title: \"Multi-Net Tracking\",\n    description: \"Monitor up to 6 nets with weight tracking and capacity alerts\",\n  },\n  {\n    icon: \"cloud\" as const,\n    title: \"Weather Integration\",\n    description: \"Stay informed with real-time weather and pressure data\",\n  },\n];\n\nexport default function OnboardingScreen() {\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation<NavigationProp>();\n  const { theme } = useTheme();\n  const { settings, updateSettings } = useApp();\n\n  React.useEffect(() => {\n    if (settings.onboardingComplete) {\n      navigation.replace(\"MatchSetup\");\n    }\n  }, [settings.onboardingComplete, navigation]);\n\n  const handleGetStarted = async () => {\n    await updateSettings({ onboardingComplete: true });\n    navigation.replace(\"MatchSetup\");\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <View\n        style={[\n          styles.content,\n          {\n            paddingTop: insets.top + Spacing[\"3xl\"],\n            paddingBottom: insets.bottom + Spacing.xl,\n          },\n        ]}\n      >\n        <Animated.View entering={FadeInDown.delay(100).springify()} style={styles.header}>\n          <View style={[styles.logoContainer, { backgroundColor: theme.backgroundDefault }]}>\n            <Image source={logoImage} style={styles.logoImage} resizeMode=\"contain\" />\n          </View>\n          <ThemedText type=\"h1\" style={styles.title}>\n            PegPro\n          </ThemedText>\n          <ThemedText type=\"body\" style={[styles.subtitle, { color: theme.textSecondary }]}>\n            Your fishing match companion\n          </ThemedText>\n        </Animated.View>\n\n        <View style={styles.features}>\n          {features.map((feature, index) => (\n            <Animated.View\n              key={feature.title}\n              entering={FadeInDown.delay(200 + index * 100).springify()}\n            >\n              <Card elevation={1} style={styles.featureCard}>\n                <View style={styles.featureContent}>\n                  <View\n                    style={[\n                      styles.featureIcon,\n                      { backgroundColor: Colors.dark.primary + \"20\" },\n                    ]}\n                  >\n                    <Feather name={feature.icon} size={24} color={Colors.dark.primary} />\n                  </View>\n                  <View style={styles.featureText}>\n                    <ThemedText type=\"h4\">{feature.title}</ThemedText>\n                    <ThemedText\n                      type=\"small\"\n                      style={{ color: theme.textSecondary, marginTop: 4 }}\n                    >\n                      {feature.description}\n                    </ThemedText>\n                  </View>\n                </View>\n              </Card>\n            </Animated.View>\n          ))}\n        </View>\n\n        <Animated.View entering={FadeInDown.delay(500).springify()} style={styles.footer}>\n          <Pressable\n            onPress={handleGetStarted}\n            style={({ pressed }) => [\n              styles.primaryButton,\n              { backgroundColor: Colors.dark.primary, opacity: pressed ? 0.8 : 1 },\n            ]}\n          >\n            <ThemedText type=\"body\" style={[styles.buttonText, { color: Colors.dark.buttonTextDark }]}>\n              Get Started\n            </ThemedText>\n            <Feather name=\"arrow-right\" size={20} color={Colors.dark.buttonTextDark} />\n          </Pressable>\n        </Animated.View>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n  },\n  header: {\n    alignItems: \"center\",\n    marginBottom: Spacing[\"3xl\"],\n  },\n  logoContainer: {\n    width: 96,\n    height: 96,\n    borderRadius: BorderRadius.lg,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.lg,\n    overflow: \"hidden\",\n  },\n  logoImage: {\n    width: 80,\n    height: 80,\n  },\n  title: {\n    marginBottom: Spacing.xs,\n  },\n  subtitle: {\n    textAlign: \"center\",\n  },\n  features: {\n    flex: 1,\n    gap: Spacing.md,\n  },\n  featureCard: {\n    padding: Spacing.lg,\n  },\n  featureContent: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  featureIcon: {\n    width: 48,\n    height: 48,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginRight: Spacing.lg,\n  },\n  featureText: {\n    flex: 1,\n  },\n  footer: {\n    marginTop: Spacing.xl,\n  },\n  primaryButton: {\n    height: 56,\n    borderRadius: BorderRadius.sm,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.sm,\n  },\n  buttonText: {\n    color: \"#FFFFFF\",\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":5848,"size_tokens":null},"server/storage.ts":{"content":"import { type User, type InsertUser } from \"@shared/schema\";\nimport { randomUUID } from \"crypto\";\n\n// modify the interface with any CRUD methods\n// you might need\n\nexport interface IStorage {\n  getUser(id: string): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n}\n\nexport class MemStorage implements IStorage {\n  private users: Map<string, User>;\n\n  constructor() {\n    this.users = new Map();\n  }\n\n  async getUser(id: string): Promise<User | undefined> {\n    return this.users.get(id);\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    return Array.from(this.users.values()).find(\n      (user) => user.username === username,\n    );\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const id = randomUUID();\n    const user: User = { ...insertUser, id };\n    this.users.set(id, user);\n    return user;\n  }\n}\n\nexport const storage = new MemStorage();\n","path":null,"size_bytes":993,"size_tokens":null},"client/components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"caption\" | \"link\";\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"caption\":\n        return Typography.caption;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","path":null,"size_bytes":1320,"size_tokens":null},"client/lib/query-client.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\n/**\n * Gets the base URL for the Express API server (e.g., \"http://localhost:3000\")\n * @returns {string} The API base URL\n */\nexport function getApiUrl(): string {\n  let host = process.env.EXPO_PUBLIC_DOMAIN;\n\n  if (!host) {\n    throw new Error(\"EXPO_PUBLIC_DOMAIN is not set\");\n  }\n\n  let url = new URL(`https://${host}`);\n\n  return url.href;\n}\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  route: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const baseUrl = getApiUrl();\n  const url = new URL(route, baseUrl);\n\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const baseUrl = getApiUrl();\n    const url = new URL(queryKey.join(\"/\") as string, baseUrl);\n\n    const res = await fetch(url, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1876,"size_tokens":null},"client/lib/storage.ts":{"content":"import AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { AppSettings, MatchState, Alarm, WeatherData, DEFAULT_SETTINGS } from \"./types\";\n\nconst KEYS = {\n  SETTINGS: \"@pegpro_settings\",\n  CURRENT_MATCH: \"@pegpro_current_match\",\n  MATCH_HISTORY: \"@pegpro_match_history\",\n  ALARMS: \"@pegpro_alarms\",\n  WEATHER: \"@pegpro_weather\",\n};\n\nexport async function getSettings(): Promise<AppSettings> {\n  try {\n    const data = await AsyncStorage.getItem(KEYS.SETTINGS);\n    if (data) {\n      return { ...DEFAULT_SETTINGS, ...JSON.parse(data) };\n    }\n    return DEFAULT_SETTINGS;\n  } catch {\n    return DEFAULT_SETTINGS;\n  }\n}\n\nexport async function saveSettings(settings: Partial<AppSettings>): Promise<void> {\n  try {\n    const current = await getSettings();\n    const updated = { ...current, ...settings };\n    await AsyncStorage.setItem(KEYS.SETTINGS, JSON.stringify(updated));\n  } catch (error) {\n    console.error(\"Failed to save settings:\", error);\n  }\n}\n\nexport async function getCurrentMatch(): Promise<MatchState | null> {\n  try {\n    const data = await AsyncStorage.getItem(KEYS.CURRENT_MATCH);\n    return data ? JSON.parse(data) : null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function saveCurrentMatch(match: MatchState | null): Promise<void> {\n  try {\n    if (match) {\n      await AsyncStorage.setItem(KEYS.CURRENT_MATCH, JSON.stringify(match));\n    } else {\n      await AsyncStorage.removeItem(KEYS.CURRENT_MATCH);\n    }\n  } catch (error) {\n    console.error(\"Failed to save match:\", error);\n  }\n}\n\nexport async function getMatchHistory(): Promise<MatchState[]> {\n  try {\n    const data = await AsyncStorage.getItem(KEYS.MATCH_HISTORY);\n    return data ? JSON.parse(data) : [];\n  } catch {\n    return [];\n  }\n}\n\nexport async function saveMatchToHistory(match: MatchState): Promise<void> {\n  try {\n    const history = await getMatchHistory();\n    history.unshift(match);\n    const limitedHistory = history.slice(0, 50);\n    await AsyncStorage.setItem(KEYS.MATCH_HISTORY, JSON.stringify(limitedHistory));\n  } catch (error) {\n    console.error(\"Failed to save match to history:\", error);\n  }\n}\n\nexport async function getAlarms(): Promise<Alarm[]> {\n  try {\n    const data = await AsyncStorage.getItem(KEYS.ALARMS);\n    return data ? JSON.parse(data) : [];\n  } catch {\n    return [];\n  }\n}\n\nexport async function saveAlarms(alarms: Alarm[]): Promise<void> {\n  try {\n    await AsyncStorage.setItem(KEYS.ALARMS, JSON.stringify(alarms));\n  } catch (error) {\n    console.error(\"Failed to save alarms:\", error);\n  }\n}\n\nexport async function getWeather(): Promise<WeatherData | null> {\n  try {\n    const data = await AsyncStorage.getItem(KEYS.WEATHER);\n    return data ? JSON.parse(data) : null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function saveWeather(weather: WeatherData): Promise<void> {\n  try {\n    await AsyncStorage.setItem(KEYS.WEATHER, JSON.stringify(weather));\n  } catch (error) {\n    console.error(\"Failed to save weather:\", error);\n  }\n}\n\nexport async function clearAllData(): Promise<void> {\n  try {\n    await AsyncStorage.multiRemove(Object.values(KEYS));\n  } catch (error) {\n    console.error(\"Failed to clear data:\", error);\n  }\n}\n","path":null,"size_bytes":3185,"size_tokens":null},"client/components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","path":null,"size_bytes":318,"size_tokens":null},"client/App.tsx":{"content":"import React, { useCallback, useEffect, useState } from \"react\";\nimport { StyleSheet, View, Text } from \"react-native\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\nimport * as Font from \"expo-font\";\nimport * as SplashScreen from \"expo-splash-screen\";\n\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { queryClient } from \"@/lib/query-client\";\n\nimport RootStackNavigator from \"@/navigation/RootStackNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\nimport { AppProvider } from \"@/lib/AppContext\";\n\nexport default function App() {\n  const [appIsReady, setAppIsReady] = useState(false);\n\n  useEffect(() => {\n    async function prepare() {\n      try {\n        await SplashScreen.preventAutoHideAsync();\n        await Font.loadAsync({\n          'Feather': require('@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts/Feather.ttf'),\n        });\n      } catch (e) {\n        console.warn(\"Font loading error:\", e);\n      } finally {\n        setAppIsReady(true);\n      }\n    }\n    prepare();\n  }, []);\n\n  const onLayoutRootView = useCallback(async () => {\n    if (appIsReady) {\n      await SplashScreen.hideAsync();\n    }\n  }, [appIsReady]);\n\n  if (!appIsReady) {\n    return null;\n  }\n\n  return (\n    <ErrorBoundary>\n      <QueryClientProvider client={queryClient}>\n        <AppProvider>\n          <SafeAreaProvider>\n            <GestureHandlerRootView style={styles.root} onLayout={onLayoutRootView}>\n              <KeyboardProvider>\n                <NavigationContainer>\n                  <RootStackNavigator />\n                </NavigationContainer>\n                <StatusBar style=\"light\" />\n              </KeyboardProvider>\n            </GestureHandlerRootView>\n          </SafeAreaProvider>\n        </AppProvider>\n      </QueryClientProvider>\n    </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":2164,"size_tokens":null},"client/components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <ThemedText type=\"h1\" style={styles.title}>\n          Something went wrong\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Please reload the app to continue.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: theme.link,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: theme.buttonText }]}\n          >\n            Try Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h2\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  title: {\n    textAlign: \"center\",\n    lineHeight: 40,\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n    lineHeight: 24,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    paddingHorizontal: Spacing[\"2xl\"],\n    minWidth: 200,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","path":null,"size_bytes":6194,"size_tokens":null},"client/hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\n\nexport function useTheme() {\n  const colorScheme = useColorScheme();\n  const isDark = colorScheme === \"dark\";\n  const theme = Colors[colorScheme ?? \"light\"];\n\n  return {\n    theme,\n    isDark,\n  };\n}\n","path":null,"size_bytes":302,"size_tokens":null},"client/screens/LiveMatchScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from \"react\";\nimport { View, StyleSheet, Pressable, Dimensions, Alert, ScrollView, Modal } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport * as Haptics from \"expo-haptics\";\nimport { activateKeepAwakeAsync, deactivateKeepAwake } from \"expo-keep-awake\";\nimport Animated, { FadeIn, useAnimatedStyle, withSpring } from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { formatTime, formatWeight, getProgressColor } from \"@/lib/utils\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nconst { width: SCREEN_WIDTH } = Dimensions.get(\"window\");\n\nexport default function LiveMatchScreen() {\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation<NavigationProp>();\n  const { theme } = useTheme();\n  const { currentMatch, updateNetWeight, updateMatchUnit, endMatch, weather, refreshWeather, settings, alarms } = useApp();\n\n  const [remainingSeconds, setRemainingSeconds] = useState(0);\n  const [isLocked, setIsLocked] = useState(false);\n  const [lockTaps, setLockTaps] = useState(0);\n  const [showUnitDropdown, setShowUnitDropdown] = useState(false);\n\n  useEffect(() => {\n    if (!currentMatch) {\n      navigation.replace(\"MatchSetup\");\n      return;\n    }\n\n    if (currentMatch.config.keepScreenOn) {\n      activateKeepAwakeAsync();\n    }\n\n    refreshWeather();\n\n    return () => {\n      deactivateKeepAwake();\n    };\n  }, [currentMatch?.id, navigation]);\n\n  useEffect(() => {\n    if (!currentMatch) return;\n\n    const updateTimer = () => {\n      const elapsed = Math.floor((Date.now() - currentMatch.startTime) / 1000);\n      const total = currentMatch.config.durationMinutes * 60;\n      const remaining = Math.max(0, total - elapsed);\n      setRemainingSeconds(remaining);\n\n      if (remaining === 0) {\n        handleMatchEnd();\n      }\n    };\n\n    updateTimer();\n    const interval = setInterval(updateTimer, 1000);\n    return () => clearInterval(interval);\n  }, [currentMatch]);\n\n  const handleMatchEnd = useCallback(async () => {\n    try {\n      await endMatch();\n      setTimeout(() => {\n        navigation.replace(\"EndMatchSummary\");\n      }, 100);\n    } catch (error) {\n      console.error(\"Error ending match:\", error);\n      navigation.replace(\"EndMatchSummary\");\n    }\n  }, [endMatch, navigation]);\n\n  const confirmEndMatch = () => {\n    Alert.alert(\n      \"End Match\",\n      \"Are you sure you want to end the match?\",\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        { text: \"End Match\", style: \"destructive\", onPress: handleMatchEnd },\n      ]\n    );\n  };\n\n  const handleLockTap = useCallback(() => {\n    if (!isLocked) {\n      setIsLocked(true);\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);\n    } else {\n      const newTaps = lockTaps + 1;\n      setLockTaps(newTaps);\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n      if (newTaps >= 3) {\n        setIsLocked(false);\n        setLockTaps(0);\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      }\n    }\n  }, [isLocked, lockTaps]);\n\n  const totalWeight = currentMatch?.nets.reduce((sum, net) => sum + net.weight, 0) || 0;\n\n  if (!currentMatch) return null;\n\n  const netCount = currentMatch.config.numberOfNets;\n  const columns = 1;\n  const netWidth = SCREEN_WIDTH - Spacing.xl * 2;\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.md }]}>\n        <Pressable\n          onPress={handleLockTap}\n          style={({ pressed }) => [styles.headerButton, { opacity: pressed ? 0.6 : 1 }]}\n        >\n          <Feather name={isLocked ? \"lock\" : \"unlock\"} size={22} color={theme.text} />\n        </Pressable>\n\n        <View style={styles.timerContainer}>\n          <ThemedText style={[styles.timer, { color: remainingSeconds < 300 ? Colors.dark.warning : theme.text }]}>\n            {formatTime(remainingSeconds)}\n          </ThemedText>\n        </View>\n\n        <View style={styles.headerRight}>\n          <Pressable\n            onPress={() => navigation.navigate(\"WeatherDetails\")}\n            style={({ pressed }) => [styles.headerButton, { opacity: pressed ? 0.6 : 1 }]}\n          >\n            <Feather name=\"cloud\" size={22} color={theme.text} />\n          </Pressable>\n          <Pressable\n            onPress={() => navigation.navigate(\"AlarmManagement\")}\n            style={({ pressed }) => [styles.headerButton, { opacity: pressed ? 0.6 : 1 }]}\n          >\n            <Feather name=\"bell\" size={22} color={alarms.length > 0 ? Colors.dark.primary : theme.text} />\n          </Pressable>\n        </View>\n      </View>\n\n      {weather ? (\n        <Pressable \n          style={styles.weatherBar}\n          onPress={() => navigation.navigate(\"WeatherDetails\")}\n        >\n          <View style={styles.weatherItem}>\n            <Feather name=\"thermometer\" size={14} color={theme.textSecondary} />\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: 4 }}>\n              {weather.temperature}°C\n            </ThemedText>\n          </View>\n          <View style={styles.weatherItem}>\n            <Feather\n              name={weather.pressureTrend === \"rising\" ? \"trending-up\" : weather.pressureTrend === \"falling\" ? \"trending-down\" : \"minus\"}\n              size={14}\n              color={theme.textSecondary}\n            />\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: 4 }}>\n              {weather.pressure}mb\n            </ThemedText>\n          </View>\n          <View style={styles.weatherItem}>\n            <Feather name=\"wind\" size={14} color={theme.textSecondary} />\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginLeft: 4 }}>\n              {weather.windSpeed}mph\n            </ThemedText>\n          </View>\n        </Pressable>\n      ) : null}\n\n      <View style={styles.unitSelectorContainer}>\n        <Pressable\n          style={[styles.unitSelector, { backgroundColor: theme.backgroundDefault }]}\n          onPress={() => !isLocked && setShowUnitDropdown(true)}\n          disabled={isLocked}\n        >\n          <ThemedText type=\"small\" style={{ color: theme.text }}>\n            {currentMatch.config.unit === \"lb/oz\" ? \"lb/oz\" : \"kg/g\"}\n          </ThemedText>\n          <Feather name=\"chevron-down\" size={16} color={theme.textSecondary} style={{ marginLeft: 4 }} />\n        </Pressable>\n      </View>\n\n      <ScrollView style={styles.netsScrollView} contentContainerStyle={[styles.netsGrid, { paddingHorizontal: Spacing.xl }]}>\n        {currentMatch.nets.map((net, index) => {\n          const percentage = net.capacity ? (net.weight / net.capacity) * 100 : 0;\n          const progressColor = getProgressColor(percentage, {\n            success: Colors.dark.success,\n            warning: Colors.dark.warning,\n            error: Colors.dark.error,\n          });\n\n          return (\n            <Animated.View\n              key={index}\n              entering={FadeIn.delay(index * 50)}\n              style={[\n                styles.netTile,\n                {\n                  width: netWidth,\n                  backgroundColor: theme.backgroundDefault,\n                },\n              ]}\n            >\n              <View style={styles.netHeader}>\n                <ThemedText type=\"small\" style={{ color: theme.textSecondary }}>\n                  Net {index + 1}\n                </ThemedText>\n              </View>\n\n              <View style={styles.netContent}>\n                <Pressable\n                  onPress={() => !isLocked && updateNetWeight(index, currentMatch.config.unit === \"kg/g\" ? -100 : -28.35)}\n                  disabled={isLocked}\n                  style={({ pressed }) => [\n                    styles.netButton,\n                    { backgroundColor: Colors.dark.errorDark, opacity: pressed || isLocked ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"minus\" size={24} color=\"#FFFFFF\" />\n                </Pressable>\n\n                <View style={styles.weightDisplay}>\n                  <ThemedText style={styles.weightText}>\n                    {formatWeight(net.weight, currentMatch.config.unit)}\n                  </ThemedText>\n                </View>\n\n                <Pressable\n                  onPress={() => !isLocked && updateNetWeight(index, currentMatch.config.unit === \"kg/g\" ? 100 : 28.35)}\n                  disabled={isLocked}\n                  style={({ pressed }) => [\n                    styles.netButton,\n                    { backgroundColor: Colors.dark.primary, opacity: pressed || isLocked ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"plus\" size={24} color=\"#FFFFFF\" />\n                </Pressable>\n              </View>\n\n              {net.capacity ? (\n                <View style={styles.progressContainer}>\n                  <View style={[styles.progressBar, { backgroundColor: theme.backgroundTertiary }]}>\n                    <View\n                      style={[\n                        styles.progressFill,\n                        {\n                          width: `${Math.min(percentage, 100)}%`,\n                          backgroundColor: progressColor,\n                        },\n                      ]}\n                    />\n                  </View>\n                  <ThemedText type=\"caption\" style={{ color: theme.textSecondary, marginTop: 4 }}>\n                    {Math.round(percentage)}%\n                  </ThemedText>\n                </View>\n              ) : null}\n            </Animated.View>\n          );\n        })}\n      </ScrollView>\n\n      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing.lg }]}>\n        <View style={[styles.totalCard, { backgroundColor: theme.backgroundDefault }]}>\n          <View style={styles.totalContent}>\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary }}>\n              Total Weight\n            </ThemedText>\n            <ThemedText type=\"h2\">\n              {formatWeight(totalWeight, currentMatch.config.unit)}\n            </ThemedText>\n          </View>\n          <Pressable\n            onPress={confirmEndMatch}\n            disabled={isLocked}\n            style={({ pressed }) => [\n              styles.endButton,\n              { backgroundColor: Colors.dark.errorDark, opacity: pressed || isLocked ? 0.6 : 1 },\n            ]}\n          >\n            <Feather name=\"stop-circle\" size={20} color=\"#FFFFFF\" />\n            <ThemedText type=\"small\" style={{ color: \"#FFFFFF\", marginLeft: 6, fontWeight: \"600\" }}>\n              End\n            </ThemedText>\n          </Pressable>\n        </View>\n      </View>\n\n      {isLocked ? (\n        <Pressable onPress={handleLockTap} style={styles.lockOverlay}>\n          <View style={styles.lockContent}>\n            <Feather name=\"lock\" size={48} color={theme.text} />\n            <ThemedText type=\"h3\" style={{ marginTop: Spacing.lg }}>\n              Screen Locked\n            </ThemedText>\n            <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginTop: Spacing.sm }}>\n              Tap 3 times to unlock ({3 - lockTaps} remaining)\n            </ThemedText>\n          </View>\n        </Pressable>\n      ) : null}\n\n      <Modal\n        visible={showUnitDropdown}\n        transparent\n        animationType=\"fade\"\n        onRequestClose={() => setShowUnitDropdown(false)}\n      >\n        <Pressable \n          style={styles.dropdownOverlay} \n          onPress={() => setShowUnitDropdown(false)}\n        >\n          <View style={[styles.dropdownMenu, { backgroundColor: theme.backgroundDefault }]}>\n            <Pressable\n              style={[\n                styles.dropdownOption,\n                currentMatch.config.unit === \"lb/oz\" && { backgroundColor: theme.backgroundTertiary },\n              ]}\n              onPress={() => {\n                updateMatchUnit(\"lb/oz\");\n                setShowUnitDropdown(false);\n              }}\n            >\n              <ThemedText type=\"body\" style={{ color: theme.text }}>lb/oz</ThemedText>\n              {currentMatch.config.unit === \"lb/oz\" && (\n                <Feather name=\"check\" size={18} color={Colors.dark.primary} />\n              )}\n            </Pressable>\n            <Pressable\n              style={[\n                styles.dropdownOption,\n                currentMatch.config.unit === \"kg/g\" && { backgroundColor: theme.backgroundTertiary },\n              ]}\n              onPress={() => {\n                updateMatchUnit(\"kg/g\");\n                setShowUnitDropdown(false);\n              }}\n            >\n              <ThemedText type=\"body\" style={{ color: theme.text }}>kg/g</ThemedText>\n              {currentMatch.config.unit === \"kg/g\" && (\n                <Feather name=\"check\" size={18} color={Colors.dark.primary} />\n              )}\n            </Pressable>\n          </View>\n        </Pressable>\n      </Modal>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingBottom: Spacing.sm,\n  },\n  headerButton: {\n    width: 44,\n    height: 44,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  headerRight: {\n    flexDirection: \"row\",\n  },\n  timerContainer: {\n    alignItems: \"center\",\n  },\n  timer: {\n    ...Typography.timer,\n  },\n  weatherBar: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing.xl,\n    paddingVertical: Spacing.sm,\n  },\n  weatherItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  unitSelectorContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.sm,\n  },\n  unitSelector: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n  },\n  dropdownOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  dropdownMenu: {\n    borderRadius: BorderRadius.sm,\n    minWidth: 150,\n    overflow: \"hidden\",\n  },\n  dropdownOption: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n  },\n  netsScrollView: {\n    flex: 1,\n  },\n  netsGrid: {\n    flexDirection: \"column\",\n    gap: Spacing.md,\n    paddingTop: Spacing.md,\n    paddingBottom: Spacing.xl,\n  },\n  netTile: {\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.md,\n  },\n  netHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    marginBottom: Spacing.sm,\n  },\n  netContent: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n  },\n  netButton: {\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  weightDisplay: {\n    flex: 1,\n    alignItems: \"center\",\n  },\n  weightText: {\n    ...Typography.bodyLarge,\n    fontWeight: \"600\",\n  },\n  progressContainer: {\n    marginTop: Spacing.sm,\n    alignItems: \"center\",\n  },\n  progressBar: {\n    width: \"100%\",\n    height: 4,\n    borderRadius: 2,\n    overflow: \"hidden\",\n  },\n  progressFill: {\n    height: \"100%\",\n    borderRadius: 2,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.md,\n  },\n  totalCard: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n  },\n  totalContent: {\n    flex: 1,\n  },\n  endButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n  },\n  lockOverlay: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(26, 35, 50, 0.95)\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  lockContent: {\n    alignItems: \"center\",\n  },\n});\n","path":null,"size_bytes":16537,"size_tokens":null},"client/lib/AppContext.tsx":{"content":"import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from \"react\";\nimport * as Haptics from \"expo-haptics\";\nimport { AppSettings, MatchState, Alarm, WeatherData, DEFAULT_SETTINGS, NetData, MatchConfig } from \"./types\";\nimport * as Storage from \"./storage\";\nimport { generateId } from \"./utils\";\n\ninterface AppContextType {\n  settings: AppSettings;\n  updateSettings: (updates: Partial<AppSettings>) => Promise<void>;\n  currentMatch: MatchState | null;\n  lastCompletedMatch: MatchState | null;\n  startMatch: (config: MatchConfig) => Promise<void>;\n  endMatch: () => Promise<void>;\n  updateNetWeight: (netIndex: number, delta: number) => void;\n  setNetWeight: (netIndex: number, weight: number) => void;\n  updateMatchUnit: (unit: \"lb/oz\" | \"kg/g\") => void;\n  alarms: Alarm[];\n  addAlarm: (alarm: Omit<Alarm, \"id\">) => Promise<void>;\n  updateAlarm: (id: string, updates: Partial<Alarm>) => Promise<void>;\n  deleteAlarm: (id: string) => Promise<void>;\n  weather: WeatherData | null;\n  refreshWeather: () => Promise<void>;\n  isLoading: boolean;\n}\n\nconst AppContext = createContext<AppContextType | undefined>(undefined);\n\nexport function AppProvider({ children }: { children: ReactNode }) {\n  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);\n  const [currentMatch, setCurrentMatch] = useState<MatchState | null>(null);\n  const [lastCompletedMatch, setLastCompletedMatch] = useState<MatchState | null>(null);\n  const [alarms, setAlarms] = useState<Alarm[]>([]);\n  const [weather, setWeather] = useState<WeatherData | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    loadInitialData();\n  }, []);\n\n  useEffect(() => {\n    if (currentMatch) {\n      Storage.saveCurrentMatch(currentMatch);\n    }\n  }, [currentMatch]);\n\n  const loadInitialData = async () => {\n    try {\n      const [loadedSettings, loadedMatch, loadedAlarms, loadedWeather] = await Promise.all([\n        Storage.getSettings(),\n        Storage.getCurrentMatch(),\n        Storage.getAlarms(),\n        Storage.getWeather(),\n      ]);\n      setSettings(loadedSettings);\n      setCurrentMatch(loadedMatch);\n      setAlarms(loadedAlarms);\n      setWeather(loadedWeather);\n    } catch (error) {\n      console.error(\"Failed to load initial data:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const updateSettings = async (updates: Partial<AppSettings>) => {\n    const newSettings = { ...settings, ...updates };\n    setSettings(newSettings);\n    await Storage.saveSettings(newSettings);\n  };\n\n  const startMatch = async (config: MatchConfig) => {\n    const nets: NetData[] = Array.from({ length: config.numberOfNets }, () => ({\n      weight: 0,\n      capacity: config.netCapacity,\n    }));\n    \n    const match: MatchState = {\n      id: generateId(),\n      config,\n      startTime: Date.now(),\n      nets,\n      isActive: true,\n    };\n    \n    setCurrentMatch(match);\n    await Storage.saveCurrentMatch(match);\n    \n    if (settings.haptics) {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n    }\n  };\n\n  const endMatch = async () => {\n    if (currentMatch) {\n      const completedMatch: MatchState = {\n        ...currentMatch,\n        endTime: Date.now(),\n        isActive: false,\n      };\n      setLastCompletedMatch(completedMatch);\n      await Storage.saveMatchToHistory(completedMatch);\n      setCurrentMatch(null);\n      await Storage.saveCurrentMatch(null);\n      \n      if (settings.haptics) {\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      }\n    }\n  };\n\n  const updateNetWeight = useCallback((netIndex: number, delta: number) => {\n    setCurrentMatch((prev) => {\n      if (!prev) return prev;\n      const newNets = [...prev.nets];\n      const newWeight = Math.max(0, newNets[netIndex].weight + delta);\n      newNets[netIndex] = { ...newNets[netIndex], weight: newWeight };\n      return { ...prev, nets: newNets };\n    });\n    \n    if (settings.haptics) {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    }\n  }, [settings.haptics]);\n\n  const setNetWeight = useCallback((netIndex: number, weight: number) => {\n    setCurrentMatch((prev) => {\n      if (!prev) return prev;\n      const newNets = [...prev.nets];\n      newNets[netIndex] = { ...newNets[netIndex], weight: Math.max(0, weight) };\n      return { ...prev, nets: newNets };\n    });\n  }, []);\n\n  const updateMatchUnit = useCallback((unit: \"lb/oz\" | \"kg/g\") => {\n    setCurrentMatch((prev) => {\n      if (!prev) return prev;\n      const oldUnit = prev.config.unit;\n      if (oldUnit === unit) return prev;\n      \n      const conversionFactor = oldUnit === \"kg/g\" && unit === \"lb/oz\" \n        ? 1 / 28.35 \n        : oldUnit === \"lb/oz\" && unit === \"kg/g\" \n        ? 28.35 \n        : 1;\n      \n      const convertedNets = prev.nets.map(net => ({\n        ...net,\n        weight: Math.round(net.weight * conversionFactor * 100) / 100,\n        capacity: net.capacity ? Math.round(net.capacity * conversionFactor * 100) / 100 : undefined,\n      }));\n      \n      return { \n        ...prev, \n        config: { ...prev.config, unit },\n        nets: convertedNets,\n      };\n    });\n  }, []);\n\n  const addAlarm = async (alarm: Omit<Alarm, \"id\">) => {\n    const newAlarm: Alarm = { ...alarm, id: generateId() };\n    const newAlarms = [...alarms, newAlarm];\n    setAlarms(newAlarms);\n    await Storage.saveAlarms(newAlarms);\n  };\n\n  const updateAlarm = async (id: string, updates: Partial<Alarm>) => {\n    const newAlarms = alarms.map((a) => (a.id === id ? { ...a, ...updates } : a));\n    setAlarms(newAlarms);\n    await Storage.saveAlarms(newAlarms);\n  };\n\n  const deleteAlarm = async (id: string) => {\n    const newAlarms = alarms.filter((a) => a.id !== id);\n    setAlarms(newAlarms);\n    await Storage.saveAlarms(newAlarms);\n  };\n\n  const refreshWeather = useCallback(async () => {\n    const mockWeather: WeatherData = {\n      temperature: 18,\n      humidity: 65,\n      windSpeed: 12,\n      pressure: 1013,\n      pressureTrend: \"stable\",\n      description: \"Partly Cloudy\",\n      lastUpdated: Date.now(),\n      isOffline: false,\n    };\n    setWeather(mockWeather);\n    await Storage.saveWeather(mockWeather);\n  }, []);\n\n  return (\n    <AppContext.Provider\n      value={{\n        settings,\n        updateSettings,\n        currentMatch,\n        lastCompletedMatch,\n        startMatch,\n        endMatch,\n        updateNetWeight,\n        setNetWeight,\n        updateMatchUnit,\n        alarms,\n        addAlarm,\n        updateAlarm,\n        deleteAlarm,\n        weather,\n        refreshWeather,\n        isLoading,\n      }}\n    >\n      {children}\n    </AppContext.Provider>\n  );\n}\n\nexport function useApp() {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error(\"useApp must be used within an AppProvider\");\n  }\n  return context;\n}\n","path":null,"size_bytes":6856,"size_tokens":null},"eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","path":null,"size_bytes":359,"size_tokens":null},"client/index.js":{"content":"import { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","path":null,"size_bytes":101,"size_tokens":null},"client/screens/SettingsScreen.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable, Switch, ScrollView } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { Feather } from \"@expo/vector-icons\";\nimport * as Haptics from \"expo-haptics\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { Card } from \"@/components/Card\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius } from \"@/constants/theme\";\nimport { WeightUnit } from \"@/lib/types\";\n\nconst AVATAR_PRESETS = [\n  { icon: \"user\", color: Colors.dark.primary },\n  { icon: \"anchor\", color: Colors.dark.secondary },\n  { icon: \"target\", color: Colors.dark.success },\n];\n\nexport default function SettingsScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const { theme } = useTheme();\n  const { settings, updateSettings } = useApp();\n\n  const handleUnitChange = (unit: WeightUnit) => {\n    updateSettings({ unit });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const handleAvatarChange = (index: number) => {\n    updateSettings({ avatarPreset: index });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const handleToggle = (key: \"haptics\" | \"sound\", value: boolean) => {\n    updateSettings({ [key]: value });\n    if (key !== \"haptics\" && settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <ScrollView\n        contentContainerStyle={[\n          styles.content,\n          {\n            paddingTop: headerHeight + Spacing.lg,\n            paddingBottom: insets.bottom + Spacing.xl,\n          },\n        ]}\n        showsVerticalScrollIndicator={false}\n      >\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.sectionLabel, { color: theme.textSecondary }]}>\n            Profile\n          </ThemedText>\n          <Card elevation={1} style={styles.sectionCard}>\n            <View style={styles.avatarSection}>\n              <ThemedText type=\"body\" style={{ marginBottom: Spacing.md }}>Avatar</ThemedText>\n              <View style={styles.avatarOptions}>\n                {AVATAR_PRESETS.map((preset, index) => (\n                  <Pressable\n                    key={index}\n                    onPress={() => handleAvatarChange(index)}\n                    style={[\n                      styles.avatarOption,\n                      {\n                        backgroundColor:\n                          settings.avatarPreset === index\n                            ? preset.color\n                            : theme.backgroundTertiary,\n                        borderColor:\n                          settings.avatarPreset === index ? preset.color : \"transparent\",\n                        borderWidth: 2,\n                      },\n                    ]}\n                  >\n                    <Feather\n                      name={preset.icon as any}\n                      size={24}\n                      color={settings.avatarPreset === index ? \"#FFFFFF\" : theme.textSecondary}\n                    />\n                  </Pressable>\n                ))}\n              </View>\n            </View>\n\n            <View style={styles.divider} />\n\n            <View style={styles.infoRow}>\n              <ThemedText type=\"body\">Display Name</ThemedText>\n              <ThemedText type=\"body\" style={{ color: theme.textSecondary }}>\n                {settings.displayName}\n              </ThemedText>\n            </View>\n          </Card>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.sectionLabel, { color: theme.textSecondary }]}>\n            Units\n          </ThemedText>\n          <Card elevation={1} style={styles.sectionCard}>\n            <View style={styles.unitSelector}>\n              <Pressable\n                onPress={() => handleUnitChange(\"lb/oz\")}\n                style={[\n                  styles.unitOption,\n                  {\n                    backgroundColor:\n                      settings.unit === \"lb/oz\" ? Colors.dark.primary : theme.backgroundTertiary,\n                  },\n                ]}\n              >\n                <ThemedText\n                  type=\"body\"\n                  style={{\n                    color: settings.unit === \"lb/oz\" ? \"#FFFFFF\" : theme.text,\n                    fontWeight: \"600\",\n                  }}\n                >\n                  lb / oz\n                </ThemedText>\n                <ThemedText\n                  type=\"caption\"\n                  style={{\n                    color: settings.unit === \"lb/oz\" ? \"#FFFFFF\" : theme.textSecondary,\n                    marginTop: 2,\n                  }}\n                >\n                  Imperial\n                </ThemedText>\n              </Pressable>\n              <Pressable\n                onPress={() => handleUnitChange(\"kg/g\")}\n                style={[\n                  styles.unitOption,\n                  {\n                    backgroundColor:\n                      settings.unit === \"kg/g\" ? Colors.dark.primary : theme.backgroundTertiary,\n                  },\n                ]}\n              >\n                <ThemedText\n                  type=\"body\"\n                  style={{\n                    color: settings.unit === \"kg/g\" ? \"#FFFFFF\" : theme.text,\n                    fontWeight: \"600\",\n                  }}\n                >\n                  kg / g\n                </ThemedText>\n                <ThemedText\n                  type=\"caption\"\n                  style={{\n                    color: settings.unit === \"kg/g\" ? \"#FFFFFF\" : theme.textSecondary,\n                    marginTop: 2,\n                  }}\n                >\n                  Metric\n                </ThemedText>\n              </Pressable>\n            </View>\n          </Card>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.sectionLabel, { color: theme.textSecondary }]}>\n            Feedback\n          </ThemedText>\n          <Card elevation={1} style={styles.sectionCard}>\n            <View style={styles.switchRow}>\n              <View style={styles.switchLabel}>\n                <Feather name=\"smartphone\" size={20} color={theme.textSecondary} />\n                <View style={{ marginLeft: Spacing.md }}>\n                  <ThemedText type=\"body\">Haptic Feedback</ThemedText>\n                  <ThemedText type=\"caption\" style={{ color: theme.textSecondary }}>\n                    Vibrate on actions\n                  </ThemedText>\n                </View>\n              </View>\n              <Switch\n                value={settings.haptics}\n                onValueChange={(value) => handleToggle(\"haptics\", value)}\n                trackColor={{ false: theme.border, true: Colors.dark.primary }}\n                thumbColor=\"#FFFFFF\"\n              />\n            </View>\n\n            <View style={styles.divider} />\n\n            <View style={styles.switchRow}>\n              <View style={styles.switchLabel}>\n                <Feather name=\"volume-2\" size={20} color={theme.textSecondary} />\n                <View style={{ marginLeft: Spacing.md }}>\n                  <ThemedText type=\"body\">Sound Effects</ThemedText>\n                  <ThemedText type=\"caption\" style={{ color: theme.textSecondary }}>\n                    Play sounds on alarms\n                  </ThemedText>\n                </View>\n              </View>\n              <Switch\n                value={settings.sound}\n                onValueChange={(value) => handleToggle(\"sound\", value)}\n                trackColor={{ false: theme.border, true: Colors.dark.primary }}\n                thumbColor=\"#FFFFFF\"\n              />\n            </View>\n          </Card>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText type=\"small\" style={[styles.sectionLabel, { color: theme.textSecondary }]}>\n            About\n          </ThemedText>\n          <Card elevation={1} style={styles.sectionCard}>\n            <View style={styles.infoRow}>\n              <ThemedText type=\"body\">Version</ThemedText>\n              <ThemedText type=\"body\" style={{ color: theme.textSecondary }}>\n                1.0.0\n              </ThemedText>\n            </View>\n          </Card>\n        </View>\n      </ScrollView>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  sectionLabel: {\n    marginBottom: Spacing.sm,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n  },\n  sectionCard: {\n    padding: Spacing.lg,\n  },\n  avatarSection: {},\n  avatarOptions: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n  },\n  avatarOption: {\n    width: 56,\n    height: 56,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  divider: {\n    height: 1,\n    backgroundColor: Colors.dark.border,\n    marginVertical: Spacing.lg,\n  },\n  infoRow: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n  },\n  unitSelector: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n  },\n  unitOption: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n  },\n  switchRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n  },\n  switchLabel: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":9673,"size_tokens":null},"client/screens/ManualWeightEditModal.tsx":{"content":"import React, { useState, useRef } from \"react\";\nimport { View, StyleSheet, Pressable, ScrollView, Platform } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useNavigation, useRoute, RouteProp } from \"@react-navigation/native\";\nimport * as Haptics from \"expo-haptics\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useApp } from \"@/lib/AppContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { formatWeight } from \"@/lib/utils\";\n\ntype RouteType = RouteProp<RootStackParamList, \"ManualWeightEdit\">;\n\nconst LB_VALUES = Array.from({ length: 201 }, (_, i) => i);\nconst OZ_VALUES = Array.from({ length: 16 }, (_, i) => i);\nconst KG_VALUES = Array.from({ length: 101 }, (_, i) => i);\nconst G_VALUES = Array.from({ length: 1000 }, (_, i) => i);\nconst ITEM_HEIGHT = 50;\nconst VISIBLE_ITEMS = 5;\n\nexport default function ManualWeightEditModal() {\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation();\n  const route = useRoute<RouteType>();\n  const { theme } = useTheme();\n  const { currentMatch, setNetWeight, settings } = useApp();\n\n  const netIndex = route.params?.netIndex ?? 0;\n  const currentWeight = currentMatch?.nets[netIndex]?.weight || 0;\n  const unit = currentMatch?.config.unit || settings.unit;\n  const isImperial = unit === \"lb/oz\";\n\n  const currentLb = Math.floor(currentWeight / 453.592);\n  const currentOz = Math.round((currentWeight % 453.592) / 28.3495);\n  \n  const getInitialKgG = () => {\n    const kg = Math.floor(currentWeight / 1000);\n    const remainder = Math.round(currentWeight % 1000);\n    const clampedG = Math.min(999, Math.max(0, remainder));\n    return { kg: Math.min(kg, 100), g: clampedG };\n  };\n  const initialKgG = getInitialKgG();\n\n  const [selectedLb, setSelectedLb] = useState(Math.min(currentLb, 200));\n  const [selectedOz, setSelectedOz] = useState(Math.min(currentOz, 15));\n  const [selectedKg, setSelectedKg] = useState(Math.min(initialKgG.kg, 100));\n  const [selectedG, setSelectedG] = useState(initialKgG.g);\n  const [hasChanged, setHasChanged] = useState(false);\n\n  const lbScrollRef = useRef<ScrollView>(null);\n  const ozScrollRef = useRef<ScrollView>(null);\n  const kgScrollRef = useRef<ScrollView>(null);\n  const gScrollRef = useRef<ScrollView>(null);\n\n  const handleConfirm = () => {\n    if (hasChanged) {\n      let weightInGrams: number;\n      if (isImperial) {\n        weightInGrams = (selectedLb * 16 + selectedOz) * 28.3495;\n      } else {\n        weightInGrams = selectedKg * 1000 + selectedG;\n      }\n      setNetWeight(netIndex, weightInGrams);\n    }\n    \n    if (settings.haptics) {\n      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n    }\n    \n    navigation.goBack();\n  };\n\n  const handleCancel = () => {\n    navigation.goBack();\n  };\n\n  const handleLbScroll = (event: any) => {\n    const y = event.nativeEvent.contentOffset.y;\n    const index = Math.round(y / ITEM_HEIGHT);\n    const clampedIndex = Math.max(0, Math.min(index, LB_VALUES.length - 1));\n    if (clampedIndex !== selectedLb) {\n      setSelectedLb(clampedIndex);\n      setHasChanged(true);\n      if (settings.haptics) {\n        Haptics.selectionAsync();\n      }\n    }\n  };\n\n  const handleOzScroll = (event: any) => {\n    const y = event.nativeEvent.contentOffset.y;\n    const index = Math.round(y / ITEM_HEIGHT);\n    const clampedIndex = Math.max(0, Math.min(index, OZ_VALUES.length - 1));\n    if (clampedIndex !== selectedOz) {\n      setSelectedOz(clampedIndex);\n      setHasChanged(true);\n      if (settings.haptics) {\n        Haptics.selectionAsync();\n      }\n    }\n  };\n\n  const handleKgScroll = (event: any) => {\n    const y = event.nativeEvent.contentOffset.y;\n    const index = Math.round(y / ITEM_HEIGHT);\n    const clampedIndex = Math.max(0, Math.min(index, KG_VALUES.length - 1));\n    if (clampedIndex !== selectedKg) {\n      setSelectedKg(clampedIndex);\n      setHasChanged(true);\n      if (settings.haptics) {\n        Haptics.selectionAsync();\n      }\n    }\n  };\n\n  const handleGScroll = (event: any) => {\n    const y = event.nativeEvent.contentOffset.y;\n    const index = Math.round(y / ITEM_HEIGHT);\n    const clampedIndex = Math.max(0, Math.min(index, G_VALUES.length - 1));\n    if (G_VALUES[clampedIndex] !== selectedG) {\n      setSelectedG(G_VALUES[clampedIndex]);\n      setHasChanged(true);\n      if (settings.haptics) {\n        Haptics.selectionAsync();\n      }\n    }\n  };\n\n  const selectLb = (value: number) => {\n    setSelectedLb(value);\n    setHasChanged(true);\n    lbScrollRef.current?.scrollTo({ y: value * ITEM_HEIGHT, animated: true });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const selectOz = (value: number) => {\n    setSelectedOz(value);\n    setHasChanged(true);\n    ozScrollRef.current?.scrollTo({ y: value * ITEM_HEIGHT, animated: true });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const selectKg = (value: number) => {\n    setSelectedKg(value);\n    setHasChanged(true);\n    kgScrollRef.current?.scrollTo({ y: value * ITEM_HEIGHT, animated: true });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const selectG = (index: number) => {\n    setSelectedG(G_VALUES[index]);\n    setHasChanged(true);\n    gScrollRef.current?.scrollTo({ y: index * ITEM_HEIGHT, animated: true });\n    if (settings.haptics) {\n      Haptics.selectionAsync();\n    }\n  };\n\n  const renderPickerItem = (value: number, isSelected: boolean) => (\n    <View\n      key={value}\n      style={[\n        styles.pickerItem,\n        isSelected && styles.pickerItemSelected,\n      ]}\n    >\n      <ThemedText\n        style={[\n          styles.pickerItemText,\n          { color: isSelected ? theme.text : theme.textSecondary },\n          isSelected && styles.pickerItemTextSelected,\n        ]}\n      >\n        {value}\n      </ThemedText>\n    </View>\n  );\n\n  const getSelectedGIndex = () => G_VALUES.indexOf(selectedG);\n\n  const getPreviewText = () => {\n    if (isImperial) {\n      return `${selectedLb} lb ${selectedOz} oz`;\n    }\n    return `${selectedKg} kg ${selectedG} g`;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.content, { paddingBottom: insets.bottom + Spacing.xl }]}>\n        <View style={styles.header}>\n          <ThemedText type=\"h3\">Edit Net {netIndex + 1} Weight</ThemedText>\n          <ThemedText type=\"small\" style={{ color: theme.textSecondary, marginTop: Spacing.xs }}>\n            Current: {formatWeight(currentWeight, unit)}\n          </ThemedText>\n        </View>\n\n        <View style={styles.pickersContainer}>\n          {isImperial ? (\n            <>\n              <View style={styles.pickerColumn}>\n                <ThemedText type=\"small\" style={[styles.pickerLabel, { color: theme.textSecondary }]}>\n                  Pounds (lb)\n                </ThemedText>\n                <View style={[styles.pickerWrapper, { backgroundColor: theme.backgroundDefault }]}>\n                  <View style={[styles.selectionIndicator, { backgroundColor: Colors.dark.primary + \"30\", borderColor: Colors.dark.primary }]} />\n                  <ScrollView\n                    ref={lbScrollRef}\n                    showsVerticalScrollIndicator={false}\n                    snapToInterval={ITEM_HEIGHT}\n                    decelerationRate=\"fast\"\n                    onMomentumScrollEnd={handleLbScroll}\n                    onScrollEndDrag={handleLbScroll}\n                    contentContainerStyle={{\n                      paddingVertical: ITEM_HEIGHT * Math.floor(VISIBLE_ITEMS / 2),\n                    }}\n                    contentOffset={{ x: 0, y: selectedLb * ITEM_HEIGHT }}\n                  >\n                    {LB_VALUES.map((value) => (\n                      <Pressable key={value} onPress={() => selectLb(value)}>\n                        {renderPickerItem(value, value === selectedLb)}\n                      </Pressable>\n                    ))}\n                  </ScrollView>\n                </View>\n              </View>\n\n              <View style={styles.pickerColumn}>\n                <ThemedText type=\"small\" style={[styles.pickerLabel, { color: theme.textSecondary }]}>\n                  Ounces (oz)\n                </ThemedText>\n                <View style={[styles.pickerWrapper, { backgroundColor: theme.backgroundDefault }]}>\n                  <View style={[styles.selectionIndicator, { backgroundColor: Colors.dark.primary + \"30\", borderColor: Colors.dark.primary }]} />\n                  <ScrollView\n                    ref={ozScrollRef}\n                    showsVerticalScrollIndicator={false}\n                    snapToInterval={ITEM_HEIGHT}\n                    decelerationRate=\"fast\"\n                    onMomentumScrollEnd={handleOzScroll}\n                    onScrollEndDrag={handleOzScroll}\n                    contentContainerStyle={{\n                      paddingVertical: ITEM_HEIGHT * Math.floor(VISIBLE_ITEMS / 2),\n                    }}\n                    contentOffset={{ x: 0, y: selectedOz * ITEM_HEIGHT }}\n                  >\n                    {OZ_VALUES.map((value) => (\n                      <Pressable key={value} onPress={() => selectOz(value)}>\n                        {renderPickerItem(value, value === selectedOz)}\n                      </Pressable>\n                    ))}\n                  </ScrollView>\n                </View>\n              </View>\n            </>\n          ) : (\n            <>\n              <View style={styles.pickerColumn}>\n                <ThemedText type=\"small\" style={[styles.pickerLabel, { color: theme.textSecondary }]}>\n                  Kilograms (kg)\n                </ThemedText>\n                <View style={[styles.pickerWrapper, { backgroundColor: theme.backgroundDefault }]}>\n                  <View style={[styles.selectionIndicator, { backgroundColor: Colors.dark.primary + \"30\", borderColor: Colors.dark.primary }]} />\n                  <ScrollView\n                    ref={kgScrollRef}\n                    showsVerticalScrollIndicator={false}\n                    snapToInterval={ITEM_HEIGHT}\n                    decelerationRate=\"fast\"\n                    onMomentumScrollEnd={handleKgScroll}\n                    onScrollEndDrag={handleKgScroll}\n                    contentContainerStyle={{\n                      paddingVertical: ITEM_HEIGHT * Math.floor(VISIBLE_ITEMS / 2),\n                    }}\n                    contentOffset={{ x: 0, y: selectedKg * ITEM_HEIGHT }}\n                  >\n                    {KG_VALUES.map((value) => (\n                      <Pressable key={value} onPress={() => selectKg(value)}>\n                        {renderPickerItem(value, value === selectedKg)}\n                      </Pressable>\n                    ))}\n                  </ScrollView>\n                </View>\n              </View>\n\n              <View style={styles.pickerColumn}>\n                <ThemedText type=\"small\" style={[styles.pickerLabel, { color: theme.textSecondary }]}>\n                  Grams (g)\n                </ThemedText>\n                <View style={[styles.pickerWrapper, { backgroundColor: theme.backgroundDefault }]}>\n                  <View style={[styles.selectionIndicator, { backgroundColor: Colors.dark.primary + \"30\", borderColor: Colors.dark.primary }]} />\n                  <ScrollView\n                    ref={gScrollRef}\n                    showsVerticalScrollIndicator={false}\n                    snapToInterval={ITEM_HEIGHT}\n                    decelerationRate=\"fast\"\n                    onMomentumScrollEnd={handleGScroll}\n                    onScrollEndDrag={handleGScroll}\n                    contentContainerStyle={{\n                      paddingVertical: ITEM_HEIGHT * Math.floor(VISIBLE_ITEMS / 2),\n                    }}\n                    contentOffset={{ x: 0, y: getSelectedGIndex() * ITEM_HEIGHT }}\n                  >\n                    {G_VALUES.map((value, index) => (\n                      <Pressable key={value} onPress={() => selectG(index)}>\n                        {renderPickerItem(value, value === selectedG)}\n                      </Pressable>\n                    ))}\n                  </ScrollView>\n                </View>\n              </View>\n            </>\n          )}\n        </View>\n\n        <View style={[styles.previewCard, { backgroundColor: theme.backgroundDefault }]}>\n          <ThemedText type=\"small\" style={{ color: theme.textSecondary }}>Selected Weight</ThemedText>\n          <ThemedText style={styles.previewText}>\n            {getPreviewText()}\n          </ThemedText>\n        </View>\n\n        <View style={styles.actions}>\n          <Pressable\n            onPress={handleCancel}\n            style={({ pressed }) => [\n              styles.actionButton,\n              styles.cancelButton,\n              { backgroundColor: theme.backgroundDefault, opacity: pressed ? 0.7 : 1 },\n            ]}\n          >\n            <ThemedText type=\"body\" style={{ fontWeight: \"600\" }}>Cancel</ThemedText>\n          </Pressable>\n          <Pressable\n            onPress={handleConfirm}\n            style={({ pressed }) => [\n              styles.actionButton,\n              styles.confirmButton,\n              { backgroundColor: Colors.dark.primary, opacity: pressed ? 0.7 : 1 },\n            ]}\n          >\n            <ThemedText type=\"body\" style={{ color: \"#FFFFFF\", fontWeight: \"600\" }}>Confirm</ThemedText>\n          </Pressable>\n        </View>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.xl,\n  },\n  header: {\n    alignItems: \"center\",\n    marginBottom: Spacing[\"2xl\"],\n  },\n  pickersContainer: {\n    flexDirection: \"row\",\n    gap: Spacing.lg,\n    marginBottom: Spacing.xl,\n  },\n  pickerColumn: {\n    flex: 1,\n  },\n  pickerLabel: {\n    textAlign: \"center\",\n    marginBottom: Spacing.sm,\n    textTransform: \"uppercase\",\n    letterSpacing: 0.5,\n  },\n  pickerWrapper: {\n    height: ITEM_HEIGHT * VISIBLE_ITEMS,\n    borderRadius: BorderRadius.sm,\n    overflow: \"hidden\",\n    position: \"relative\",\n  },\n  selectionIndicator: {\n    position: \"absolute\",\n    top: ITEM_HEIGHT * Math.floor(VISIBLE_ITEMS / 2),\n    left: 0,\n    right: 0,\n    height: ITEM_HEIGHT,\n    borderWidth: 2,\n    borderRadius: BorderRadius.xs,\n    zIndex: 1,\n    pointerEvents: \"none\",\n  },\n  pickerItem: {\n    height: ITEM_HEIGHT,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  pickerItemSelected: {},\n  pickerItemText: {\n    ...Typography.h3,\n    fontWeight: \"400\",\n  },\n  pickerItemTextSelected: {\n    fontWeight: \"700\",\n  },\n  previewCard: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    marginBottom: Spacing.xl,\n  },\n  previewText: {\n    ...Typography.h2,\n    marginTop: Spacing.xs,\n  },\n  actions: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n  },\n  actionButton: {\n    flex: 1,\n    height: 56,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  cancelButton: {},\n  confirmButton: {},\n});\n","path":null,"size_bytes":15295,"size_tokens":null},"client/navigation/RootStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\n\nimport OnboardingScreen from \"@/screens/OnboardingScreen\";\nimport MatchSetupScreen from \"@/screens/MatchSetupScreen\";\nimport LiveMatchScreen from \"@/screens/LiveMatchScreen\";\nimport EndMatchSummaryScreen from \"@/screens/EndMatchSummaryScreen\";\nimport AlarmManagementScreen from \"@/screens/AlarmManagementScreen\";\nimport AddEditAlarmScreen from \"@/screens/AddEditAlarmScreen\";\nimport WeatherDetailsScreen from \"@/screens/WeatherDetailsScreen\";\nimport SettingsScreen from \"@/screens/SettingsScreen\";\nimport ManualWeightEditModal from \"@/screens/ManualWeightEditModal\";\n\nexport type RootStackParamList = {\n  Onboarding: undefined;\n  MatchSetup: undefined;\n  LiveMatch: undefined;\n  EndMatchSummary: undefined;\n  AlarmManagement: undefined;\n  AddEditAlarm: { alarmId?: string };\n  WeatherDetails: undefined;\n  Settings: undefined;\n  ManualWeightEdit: { netIndex: number };\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\n\nexport default function RootStackNavigator() {\n  const screenOptions = useScreenOptions();\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      <Stack.Screen\n        name=\"Onboarding\"\n        component={OnboardingScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen\n        name=\"MatchSetup\"\n        component={MatchSetupScreen}\n        options={{ headerTitle: \"New Match\" }}\n      />\n      <Stack.Screen\n        name=\"LiveMatch\"\n        component={LiveMatchScreen}\n        options={{ headerShown: false, gestureEnabled: false }}\n      />\n      <Stack.Screen\n        name=\"EndMatchSummary\"\n        component={EndMatchSummaryScreen}\n        options={{ headerTitle: \"Match Complete\", gestureEnabled: false }}\n      />\n      <Stack.Screen\n        name=\"AlarmManagement\"\n        component={AlarmManagementScreen}\n        options={{ headerTitle: \"Alarms\" }}\n      />\n      <Stack.Screen\n        name=\"AddEditAlarm\"\n        component={AddEditAlarmScreen}\n        options={{ headerTitle: \"New Alarm\", presentation: \"modal\" }}\n      />\n      <Stack.Screen\n        name=\"WeatherDetails\"\n        component={WeatherDetailsScreen}\n        options={{ headerTitle: \"Weather\" }}\n      />\n      <Stack.Screen\n        name=\"Settings\"\n        component={SettingsScreen}\n        options={{ headerTitle: \"Settings\" }}\n      />\n      <Stack.Screen\n        name=\"ManualWeightEdit\"\n        component={ManualWeightEditModal}\n        options={{ \n          headerTitle: \"Edit Weight\",\n          presentation: \"modal\",\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":2688,"size_tokens":null},"replit.md":{"content":"# PegPro - Fishing Match Tracker\n\n## Overview\nPegPro is a native React Native mobile app for tracking fishing match competitions. It allows anglers to monitor multiple nets, track weights, manage alarms, view weather data, and generate match summaries.\n\n## Tech Stack\n- **Frontend**: React Native with Expo SDK\n- **State Management**: React Context + AsyncStorage for persistence\n- **Navigation**: React Navigation 7 (Stack-only navigation)\n- **Styling**: StyleSheet with custom theme (dark navy, coral-red, teal-blue)\n\n## Project Structure\n```\nclient/\n├── App.tsx                    # Root component with providers\n├── components/                # Reusable UI components\n├── constants/theme.ts         # Design tokens (colors, spacing, typography)\n├── hooks/                     # Custom React hooks\n├── lib/\n│   ├── AppContext.tsx         # Global state management\n│   ├── storage.ts             # AsyncStorage utilities\n│   ├── types.ts               # TypeScript interfaces\n│   └── utils.ts               # Helper functions\n├── navigation/\n│   └── RootStackNavigator.tsx # Stack navigation setup\n└── screens/\n    ├── OnboardingScreen.tsx   # First-time user welcome\n    ├── MatchSetupScreen.tsx   # Configure new match\n    ├── LiveMatchScreen.tsx    # Core match tracking UI\n    ├── ManualWeightEditModal.tsx  # Numeric weight entry\n    ├── AlarmManagementScreen.tsx  # View/manage alarms\n    ├── AddEditAlarmScreen.tsx     # Create/edit alarms\n    ├── WeatherDetailsScreen.tsx   # Weather information\n    ├── EndMatchSummaryScreen.tsx  # Match results\n    └── SettingsScreen.tsx         # App preferences\n```\n\n## Key Features\n- **Multi-Net Tracking**: Monitor 1-6 nets with +/- weight controls\n- **Match Timer**: Countdown timer with visual warnings\n- **Alarms**: One-time, repeat, and pattern-based reminders\n- **Weather**: Temperature, humidity, wind, pressure tracking\n- **Lock Mode**: Prevent accidental touches during matches\n- **Export/Share**: Share match summaries\n\n## Color Palette\n- **Backgrounds**: Deep Black (#05080B), Card (#0B1218), Elevated (#111A22), Border (#1C2A35)\n- **Primary Accent (Neon Green)**: #3CFFB0 (soft: #2EDC9C, progress: #41F5A3)\n- **Danger Red**: #FF4D4D (dark button: #8B1E1E)\n- **Warning Yellow**: #F6C343 (amber: #E9B949, muted: #D8B55A)\n- **Action Blue**: #2F8CFF (muted: #1E5FAF)\n- **Text**: Primary (#FFFFFF), Secondary (#A8B3BD), Muted (#6F7C87)\n- **Button Text**: Primary buttons use dark text (#05120C) on green background\n- **Effects**: Neon glow effects instead of shadows (green/red/blue glows)\n\n## Running the App\n- Development: `npm run dev` (starts Expo on port 8081, Express on port 5000)\n- Test on device: Scan QR code in Expo Go app\n","path":null,"size_bytes":2826,"size_tokens":null},"client/types/assets.d.ts":{"content":"declare module \"@assets/*\" {\n  const value: number;\n  export default value;\n}\n\ndeclare module \"@assets/generated_images/pegpro_fishing_float_app_icon.png\" {\n  const value: number;\n  export default value;\n}\n","path":null,"size_bytes":206,"size_tokens":null}},"version":2}